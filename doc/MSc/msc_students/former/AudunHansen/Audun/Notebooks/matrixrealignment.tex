
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass{article}

    
    
    \usepackage{graphicx} % Used to insert images
    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{color} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    

    
    
    \definecolor{orange}{cmyk}{0,0.4,0.8,0.2}
    \definecolor{darkorange}{rgb}{.71,0.21,0.01}
    \definecolor{darkgreen}{rgb}{.12,.54,.11}
    \definecolor{myteal}{rgb}{.26, .44, .56}
    \definecolor{gray}{gray}{0.45}
    \definecolor{lightgray}{gray}{.95}
    \definecolor{mediumgray}{gray}{.8}
    \definecolor{inputbackground}{rgb}{.95, .95, .85}
    \definecolor{outputbackground}{rgb}{.95, .95, .95}
    \definecolor{traceback}{rgb}{1, .95, .95}
    % ansi colors
    \definecolor{red}{rgb}{.6,0,0}
    \definecolor{green}{rgb}{0,.65,0}
    \definecolor{brown}{rgb}{0.6,0.6,0}
    \definecolor{blue}{rgb}{0,.145,.698}
    \definecolor{purple}{rgb}{.698,.145,.698}
    \definecolor{cyan}{rgb}{0,.698,.698}
    \definecolor{lightgray}{gray}{0.5}
    
    % bright ansi colors
    \definecolor{darkgray}{gray}{0.25}
    \definecolor{lightred}{rgb}{1.0,0.39,0.28}
    \definecolor{lightgreen}{rgb}{0.48,0.99,0.0}
    \definecolor{lightblue}{rgb}{0.53,0.81,0.92}
    \definecolor{lightpurple}{rgb}{0.87,0.63,0.87}
    \definecolor{lightcyan}{rgb}{0.5,1.0,0.83}
    
    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{matrixrealignment}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=blue,
      linkcolor=darkorange,
      citecolor=darkgreen,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{Flexible matrix realignment}\label{flexible-matrix-realignment}

    In this document, we will discuss a convenient (and hopefully efficient)
way of realigning the matrix elements of the different tensors entering
the CCD amplitude equation, so that all diagrams may be calculated by
matrix multiplication.

In its current implementations (in python/numpy and c++/armadillo), I
utilize sparse matrices to store all elements. This has some advantage
when it comes to memory consumption, since only nonzero elements are
stored. The current drawback seems to be the efficiency of matrix
multiplications, since this process consumes notably more time for
sparse matrices than the block diagonalization approach. This is due to
the way the elements are stored.

    \section{The CCD amplitude equation}\label{the-ccd-amplitude-equation}

The T2 amplitude for the CCD truncation is

    \[ t^{ab}_{ij} \epsilon^{ab}_{ij} = \frac{1}{2} \sum_{cd} \langle ab \vert \vert cd \rangle t^{cd}_{ij} + \frac{1}{2} \sum_{kl} \langle kl \vert \vert ij \rangle t^{ab}_{kl} + \hat{P}(ij \vert ab) \sum_{kc} \langle kb \vert \vert cj \rangle t^{ac}_{ik} + \frac{1}{4} \sum_{klcd} \langle kl \vert \vert cd \rangle t^{cd}_{ij} t^{ab}_{kl} + \hat{P}(ij) \sum_{klcd} \langle kl \vert \vert cd \rangle t^{ac}_{ik} t^{bd}_{jl} - \frac{1}{2} \hat{P}(ij) \sum_{klcd} \langle kl \vert \vert cd \rangle t^{dc}_{ik} t^{ab}_{lj} - \frac{1}{2} \hat{P}(ab)\sum_{klcd}\langle kl \vert \vert cd \rangle t^{ac}_{lk} t^{db}_{ij} \]

    This equation is commonly solved iteratively by guessing some initial
amplitude, typically the ones corresponding to the MBPT(2) energy, then
solving for the RHS to yield the new approximation. The iterative
process is halted when some convergence criteria is fulfilled, possibly
when the change in amplitudes between the iterations subpasses some
threshold or when the resulting energy converges towards some value.

    The structure of this equation motivates a subdivision into
\emph{linear} and \emph{quadratic} terms in order of the unknown
amplitudes \(t^{ab}_{ij}\).

By denoting linear terms by \(L_n\) and quadratic terms by \(Q_n\), we
may then express the equation as

    \[ t^{ab}_{ij} \epsilon^{ab}_{ij} = L_1(t^{ab}_{ij}) + L_2(t^{ab}_{ij}) + L_3(t^{ab}_{ij}) + Q_1(t^{ab}_{ij}) + Q_2(t^{ab}_{ij}) + Q_3(t^{ab}_{ij}) + Q_4(t^{ab}_{ij}) \]

    Each term on the RHS above corresponds to a one of the diagram formed by
contracting the similarity transformed hamiltonian with the exponential
ansatz.

In the following sections, we will discuss how these terms may be
calculated as matrix multiplications.

    \section{Setting up the matrices}\label{setting-up-the-matrices}

Every factor in the terms above is a tensor of rank 4. To utilize the
advantages of matrix multiplications, we need to represent these tensors
as matrices (tensors of rank 2). In effect, we need a unambiguous
mapping from rank 4 to rank 2.

One very straightforward such mapping is derived by considering the
indexes and their associated length;

\[ p = [0,1,2,3, ..., N_p] \]

A matrix will have only two indices, so we then map the amplitudes and
interactions onto matrices by for example

\[ \langle pq || rs \rangle = \langle p + q N_p || r + s  N_r \rangle \]

Now we have the rows of the matrix contained in the bra part of the RHS
above, and the columns is contained in the ket.

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\subsection{Example usage}\label{example-usage}

Since a high accuracy calculation will involve a large number of
particle states, the L1 term is computationally expensive (it is a sum
over particle states). A naive implementation will typically consist of
four nested for-loops (for a,b,c,d), and will require a lot of flops.

If we instead map it onto matrices, so that

\[\sum_{cd} \langle ab \vert \vert cd \rangle t^{cd}_{ij} = \sum_{cd} \langle a+ bN_a \vert \vert c+dN_c \rangle t^{c+dN_c}_{i+jN_i} = \sum_{\gamma} \langle \alpha \vert \vert \gamma \rangle t^{\gamma}_{\beta}\]

We easily see that the whole diagram may be calculated as a matrix
multiplication

\[L_1 = V^{\alpha}_\gamma * T^\gamma_\beta\]

    \section{Flexible indexing}\label{flexible-indexing}

Because of the occurances of indices in the contributions \(L_1, L_2\)
and \(Q_1\), these diagrams are especially straighforward to set up as
matrix multiplications. In the remaining diagrams, we will need to
realign the matrix elemenent before the multiplication is performed.

In the following we will utilize the following matrix notation:

\[t^{cd}_{ij} \equiv | cd \rangle T \langle ij |\]

The \(L_1\) term is then calculated as

\[L_1 = (| a + bN_a\rangle V \langle c + dN_c | )( | c + dN_c \rangle T \langle i + jN_i|) \]

The alignment problem is related to diagrams where indices does not
occur in corresponding bra and kets as for \(L_1\) above. For example,
we have for the \(L_3\) term (prefactors and permutations left out)

\[L_3 = \sum_{kc} \langle kb \vert \vert cj \rangle t^{ac}_{ik} \]

To set up a matrix for V and T, we need the indices \(k\) and \(c\) to
coincide in the bra and ket of V and T respectively. In effect, we want

\[\tilde{L}_3 =   (| b + jN_b\rangle V \langle k + cN_k | )( | k + cN_k \rangle T \langle a + iN_a|) \]

Where the indices of \(\tilde{L}_3\) does not align with the indices of
\(L_3\), but since the elements are the same we only need to perform a
simple realignment back to the original column- and row indexing.

\[\tilde{L}_3 \rightarrow L_3\]

The process is maybe most easily understood as a \emph{generalized
transpose} for tensors with \(rank>2\).

    \section{Subdivision of the interaction
matrix}\label{subdivision-of-the-interaction-matrix}

As may be seen from the CCD equation, only certain elements from the
interaction matrix actually enters the calculation.

This makes it convenient to subdivide the interaction matrix into blocks
in

\[V^{pp}_{pp}\] \[V^{hh}_{hh}\] \[V^{hh}_{pp}\] \[V^{pp}_{hh}\]
\[V^{hp}_{ph}\]

In these matrices \(h\) and \(p\) denotes hole and particle states.
Their location in the full interaction matrix is visualized below.

\begin{longtable}[c]{@{}lllll@{}}
\toprule
& hh & hp & ph & pp\tabularnewline
\midrule
\endhead
hh & \(V^{hh}_{hh}\) & & & \(V^{hh}_{pp}\)\tabularnewline
hp & & & \(V^{hp}_{ph}\) &\tabularnewline
ph & & & &\tabularnewline
pp & \(V^{pp}_{hh}\) & & & \(V^{pp}_{pp}\)\tabularnewline
\bottomrule
\end{longtable}

A lot of symmetries is also involved in these elements, so we do not
need to actually calculate all quantities involved prior to the CCD
calculation.

    \section{The actual alignments}\label{the-actual-alignments}

We will now derive the various realignments that we need to perform to
solve the full CCD amplitude equation by matrix multiplications. These
expressions are meant to correspond with the actual implementation in
fermicc, so instead of having direct corresponding indices, we use
\(p,q,r,s\) for the first, second, third and fourth index respectively
(as they occur in the tensors ``native'' representation.)

The realignments/permutations are listed in the table below. Note that
any prefactors or permutations is omitted from the expressions.

    \subsubsection{Table: Realignment of matrix elements in interaction and
amplitudes}\label{table-realignment-of-matrix-elements-in-interaction-and-amplitudes}

\begin{longtable}[c]{@{}lllll@{}}
\toprule
Diagram & Expression & Aligned multiplication & Interaction &
Amplitude(1)\tabularnewline
\midrule
\endhead
\(L_1\) & \$ \sum\emph{\{cd\} \langle ab \vert \vert cd
\rangle t\^{}\{cd\}}\{ij\}\$ &
\((|ab \rangle V \langle cd|)(|cd \rangle T \langle ij|)\) &
&\tabularnewline
\(L_2\) & \$ \sum\emph{\{kl\} \langle kl \vert \vert ij
\rangle t\^{}\{ab\}}\{kl\}\$ &
\((|ab \rangle T \langle kl|)(|kl \rangle V \langle ij|)\) &
&\tabularnewline
\(L_3\) & \$ \sum\emph{\{kc\} \langle kb \vert \vert cj
\rangle t\^{}\{ac\}}\{ik\}\$ &
\((| jb \rangle \tilde{V} \langle ck | )( | ck \rangle \tilde{T} \langle ai|)\)
& \(V^{pq}_{rs} = \tilde{V}^{sq}_{rp}\) &
\(T^{pq}_{rs} = \tilde{T}^{qs}_{pr}\)\tabularnewline
\(Q_1\) & \$ \sum\emph{\{klcd\} \langle kl \vert \vert cd
\rangle t\^{}\{cd\}}\{ij\} t\^{}\{ab\}\emph{\{kl\}\$ \textbar{}
\((|ab \rangle T \langle kl|)(|kl \rangle V \langle cd|)(|cd \rangle T \langle ij|)\)
\textbar{} \textbar{} \textbar{}\textbar{}\textbar{} \textbar{}\(Q_2\)
\textbar{}\$ \sum}\{klcd\} \langle kl \vert \vert cd
\rangle t\^{}\{ac\}\emph{\{ik\} t\^{}\{bd\}}\{jl\}\$ &
\((|ai \rangle T \langle kc|)(|kc \rangle V \langle ld|)(|ld \rangle T \langle bj|)\)
& \(V^{pq}_{rs} = \tilde{V}^{pr}_{qs}\) &
\(T^{pq}_{rs} = \tilde{T}^{pr}_{sq}\)\tabularnewline
\(Q_3\) & \$ \sum\emph{\{klcd\} \langle kl \vert \vert cd
\rangle t\^{}\{dc\}}\{ik\} t\^{}\{ab\}\emph{\{lj\}\$ \textbar{}
\((|abj \rangle T \langle l|)(|l \rangle V \langle kcd|)(|kcd \rangle T \langle i|)\)
\textbar{} \(V^{pq}_{rs} = \tilde{V}^{q}_{prs}\) \textbar{}
\(T^{pq}_{rs} = \tilde{T}^{pqs}_{r}\)
\textbar{}\(T^{pq}_{rs} = \tilde{T}^{sqp}_{r}\)\textbar{}\((Q_3)^{pq}_{rs} = \tilde{(Q_3)}^{pqs}_{r}\)\textbar{}
\textbar{}\(Q_4\) \textbar{}\$ \sum}\{klcd\}\langle kl \vert \vert cd
\rangle t\^{}\{ac\}\emph{\{lk\} t\^{}\{db\}}\{ij\}\$ &
\((|a \rangle T \langle klc|)(|klc \rangle V \langle d|)(|d \rangle T \langle bij|)\)
& \(V^{pq}_{rs} = \tilde{V}^{pqr}_{s}\) &
\(T^{pq}_{rs} = \tilde{T}^{p}_{srq}\)\tabularnewline
\bottomrule
\end{longtable}

    \section{Implementation}\label{implementation}

A standard format for representing sparse matrices is the COOrdinate
format. In this format the matrix elements are stored in three arrays,
one for the actual values, and two for each coordinate in the matrix.
All elements not stored in these arrays are by default zero.

For example, the matrix below

\begin{longtable}[c]{@{}lllll@{}}
\toprule
& 0 & 1 & 2 & 3\tabularnewline
\midrule
\endhead
0 & & 1 & & 3\tabularnewline
1 & & & &\tabularnewline
2 & & & &\tabularnewline
3 & 2 & & &\tabularnewline
\bottomrule
\end{longtable}

May be represented in the following way

\begin{longtable}[c]{@{}llll@{}}
\toprule
element & 0 & 1 & 2\tabularnewline
\midrule
\endhead
values & 1 & 3 & 2\tabularnewline
row & 0 & 0 & 3\tabularnewline
column & 1 & 3 & 0\tabularnewline
\bottomrule
\end{longtable}

This is however not the most optimal (least space consuming)
representation, so formats such as CSC (compressed sparse column) or CSR
(compressed sparse row) is commonly utilized. Armadillos sp\_mat object
is of the first type, meaning that the array containing the column
indices is compressed by replacing it with a pointer to the first
element occuring in each column. This way, the index in the column
pointer array denotes the actual column in which the following elements
occur (up until the pointer to the next element). To access the actual
column index of any element in the matrix, we therefore have to unpack
this array first.

http://netlib.org/linalg/html\_templates/node92.html

One such unpacking procedure written for the python/numpy implementation
of the CCD calculation is given below

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{k}{def} \PY{n+nf}{unpack\PYZus{}indptr}\PY{p}{(}\PY{n}{indptr}\PY{p}{)}\PY{p}{:}
            \PY{c}{\PYZsh{}Unpack compressed indices}
            \PY{c}{\PYZsh{}indptr is the array to be uncompressed}
            \PY{n}{I} \PY{o}{=}\PY{n}{zeros}\PY{p}{(}\PY{n}{indptr}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{dtype} \PY{o}{=} \PY{n+nb}{int}\PY{p}{)}
            \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n+nb}{len}\PY{p}{(}\PY{n}{indptr}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
                \PY{n}{I}\PY{p}{[}\PY{n}{indptr}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{:}\PY{n}{indptr}\PY{p}{[}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]} \PY{o}{=} \PY{n}{i}
            \PY{k}{return} \PY{n}{I}
\end{Verbatim}

    When the matrices are represented in this way, the realignment procedure
becomes trivial. Given elements, row- and columnindices, we may easily
obtain the rank 4 indices, as is done in the following python example:

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{k+kn}{from} \PY{n+nn}{numpy} \PY{k+kn}{import} \PY{o}{*}
        \PY{n}{Np} \PY{o}{=} \PY{l+m+mi}{14}
        \PY{n}{Nq} \PY{o}{=} \PY{l+m+mi}{14}
        \PY{n}{Nr} \PY{o}{=} \PY{l+m+mi}{14}
        \PY{n}{Ns} \PY{o}{=} \PY{l+m+mi}{14}
        
        \PY{n}{row} \PY{o}{=} \PY{n}{arange}\PY{p}{(}\PY{n}{Np}\PY{o}{*}\PY{n}{Nq}\PY{p}{)}
        \PY{n}{col} \PY{o}{=} \PY{n}{arange}\PY{p}{(}\PY{n}{Nr}\PY{o}{*}\PY{n}{Ns}\PY{p}{)}
        
        \PY{n}{p} \PY{o}{=} \PY{n}{row}\PY{o}{/}\PY{o}{/}\PY{n}{Np}
        \PY{n}{q} \PY{o}{=} \PY{n}{row}\PY{o}{\PYZpc{}}\PY{k}{Np}
        \PY{n}{r} \PY{o}{=} \PY{n}{col}\PY{o}{/}\PY{o}{/}\PY{n}{Nr}
        \PY{n}{s} \PY{o}{=} \PY{n}{col}\PY{o}{\PYZpc{}}\PY{k}{Nr}
\end{Verbatim}

    Next up, an example of how to recast the elements to a ``realigned''
matrix

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{n}{row} \PY{o}{=} \PY{n}{q} \PY{o}{+} \PY{n}{r}\PY{o}{*}\PY{n}{Nq}
        \PY{n}{col} \PY{o}{=} \PY{n}{s} \PY{o}{+} \PY{n}{p}\PY{o}{*}\PY{n}{Ns}
        
        \PY{c}{\PYZsh{}New matrix dimensions: (Nq*Nr), (Ns*Np)}
        \PY{c}{\PYZsh{}Matrix elements \PYZdq{}val\PYZdq{} remain the same}
\end{Verbatim}

    \section{Density of the interactions}\label{density-of-the-interactions}

Due to the many kroenecker deltas occuring in the HEG interaction, we
find that the interaction matrix has a denisty of approx \textless{}
1\%, meaning that this is a case where utilizing sparse storage is
reasonable.

    \section{Pros and cons of the sparse
scheme}\label{pros-and-cons-of-the-sparse-scheme}

The main drawback of the sparse approach will however be the efficiency
of the matrix multiplications when compared to the block diagonalization
scheme. When block diagonalized, the calculations may be performed in
mere seconds.

The main advantage of this approach is, to my expection, that the
implementation of the CCSDT truncation will be very straightforward
codewise, low on memory consumption, and possible to perform also as
serial computations. (unless computational cost exceeds the expected
progression).

There is a number of routes that may possibly speed up the sparse matrix
multiplications. I could continue optimizing the COO-scheme, find a
replacement for armadillo, or possibly try a CUDA im

One is to implement a similar subdivision of the matrix elements that is
done for the block diagonal scheme. By simply skipping casting the
elements to a sparse matrix in the first place, I attempted to just
perform the multiplication directly on the elements stored in a
COOrdinate format with a subdivision similar to the block diagonal
scheme. This successfully decreased the time spent on multiplication
with a factor of about 0.007 when compared to the naive implementation,
but the native scipy.sparse multiplication operation still outperformed
this algorithm by a factor of about 0.001 when compared to the optimized
implementation. (meaning a factor of about 0.00007 compared to the naive
scheme).

On the other hand, Armadillo's native sparse multiplication did not
compare well to the scipy algorithm, as it was only about a factor of
0.1 faster than the optimized algorithm.

    \subsection{Benchmarking sparse
multiplication}\label{benchmarking-sparse-multiplication}

\begin{longtable}[c]{@{}lll@{}}
\toprule
Library/Algorithm & Time (s) & Fractional time\tabularnewline
\midrule
\endhead
Na√Øve & 2.07011318512 & 1\tabularnewline
Optimized & 0.042023196118 & 0.02029995094957284\tabularnewline
Scipy & 0.000879618572071 & 0.00042491327449808525\tabularnewline
Armadillo & 0.025932 & 0.012526851278664156\tabularnewline
\bottomrule
\end{longtable}

\emph{The table lists the time spent on performing a multiplication of
the \(V_{pp}^{pp}\) matrix with itself, with a dimension of 576x567 and
a density of about 0.75 \% . (ratio of nonzero elements)}

It should be noted that the results from armadillo does not directly
compare as they were calculated in a virtual ubuntu environment. (Oracle
VM VirtualBox, no cap on CPU and plenty of RAM).

    \section{Considering alternative
libraries}\label{considering-alternative-libraries}

Mainly three libraries for the C++ implementation are up for
consideration:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Eigen (http://eigen.tuxfamily.org/index.php?title=Main\_Page)
\item
  CSparse (http://www.cise.ufl.edu/research/sparse/CSparse/)
\item
  CUSparse https://developer.nvidia.com/cuSPARSE
\end{enumerate}

The first two seems to have optimized support for sparse matrix
multiplication (and a lot of other functionality). The third certainly
meets this criteria, but it is also dependent on the GPU/CUDA. Scaling
should also be taken into account, as libraries such as CUDA may or may
not (https://www.cs.fsu.edu/research/projects/aseshpande.pdf
https://www.cs.fsu.edu/research/projects/rose\_report.pdf ) perform
slower for small systems compared to libraries utilizing the CPU.
Another consideration in this matter is that the upcoming CCSDT
implementation should be expected to require parallellization (in MPI),
so it will be of great advantage if the implementation is easily
extended to parallel computation.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}}]:} 
\end{Verbatim}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
