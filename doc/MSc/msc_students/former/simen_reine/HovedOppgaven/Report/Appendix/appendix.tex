\chapter{Appendix}



% *************************************************************
% *                                                           *
% *                        Program Code                       *
% *                                                           *
% *************************************************************
%
%
%
\section{Program Code}

% *************************************************************
% *                                                           *
% *                          MAIN.CPP                         *
% *                                                           *
% *************************************************************
\subsection{main.cpp}
\begin{lstlisting}
#include <mpi.h>

using namespace std;

#include "Ref/Ref.h"
#include "Domain/Domain.h"
#include "Coor/Coor.h"
#include "Vmc/Vmc.h"
#include "SlaterDet/SlaterDet.h"
#include "FuncUpDown/FuncUpDown.h"

int main(int argn, char* args[]) {

  // ************************* MPI ***********************
  int rank, size;
  MPI::Init(argn, args);
  rank = MPI::COMM_WORLD.Get_rank();
  size = MPI::COMM_WORLD.Get_size();
  system("renice +19 -u simensr");

  // Defines the form of the SlaterDet template
  typedef SlaterDet<FuncUp<CoorSpinDiff>, 
    FuncDown<CoorSpinDiff> > SlaterDeterminant;

  // ************************ Domain *********************
  Ref<Domain> domain;
  char*       initFileName = "init";
  domain      = new Domain(initFileName, rank, size);
  domain().init();

  
  // ************************* vmc ***********************
  Ref<Vmc<SlaterDeterminant> > vmc;
  vmc = new Vmc<SlaterDeterminant >(domain());
  vmc().run();

  // ************************* MPI ***********************
  MPI::Finalize();
  return 0;
}
\end{lstlisting}

\newpage

% *************************************************************
% *                                                           *
% *                          DOMAIN.H                         *
% *                                                           *
% *************************************************************
\subsection{Domain.h}
\begin{lstlisting}
#ifndef Domain_IS_INCLUDED
#define Domain_IS_INCLUDED

#include "../Paramizer/Paramizer.h"
#include "../Coor/Coor.h"
#include "../Random/Random.h"
#include "../Distance/Distance.h"
#include "../SpinFactors/SpinFactors.h"
#include "../Ref/Ref.h"
#include "../Random/Random.h"
#include "../fFunction/fFunction.h"

#include <fstream>
#include <string>
#include <iostream>
#include <cstdio>
using namespace std;

#ifndef copyArray_IS_INCLUDED
#define copyArray_IS_INCLUDED
// *************************** copyArray ***********************
inline void copyArray(double* fromArray, double* toArray, int dim) {
  double* _fromArray = fromArray - 1;
  double* _toArray = toArray - 1;
  for (int i=0; i<dim; i++)
    (*++_toArray) = (*++_fromArray);
}
#endif

#ifndef dotProduct_IS_INCLUDED
#define dotProduct_IS_INCLUDED
// ************************** dotProduct ***********************
inline double dotProduct(double* array1, double* array2, int dim) {
  double* a1 = array1 - 1;
  double* a2 = array2 - 1;
  double product = 0;
  for (int i=0; i<dim; i++)
    product += (*++a1)*(*++a2);
  return product;
}
#endif

#ifndef odd_IS_INCLUDED
#define odd_IS_INCLUDED
// ***************************** odd ***************************
inline int odd(int number) {
  return (number - number/2);
}
// ********************** centerOfOddInteger *******************
inline int centerOfOddInteger(int oddInteger) {
  if (!odd(oddInteger)) cerr << "Error finding center of integer "
			     << "in Domain; integer is even (=" 
			     << oddInteger << ")!" << endl;
  else return ((oddInteger+1)/2);
}
// ****************** centerOfOddIntegerMinusOne ***************
inline int centerOfOddIntegerMinusOne(int oddInteger) {
  return (centerOfOddInteger(oddInteger)-1);
}
#endif





// *************************************************************
// *                                                           *
// *                           DOMAIN                          *
// *                                                           *
// *************************************************************
class Domain {
 // ************************************************************
 // *                 PROTECTED ALGORITHMS                     *
 // ************************************************************
 protected:
  // ************************** MPI ****************************
  int rank; // Prosess number
  int size; // Number of prosesses


  // ****************** Input and Output Files *****************
  char*    standardInput;
  char*    electronConfiguration;
  char*    randomConfig;
  char*    uniDirectionalConfig;
  char*    slaterParam;
  char*    fixedParamsUp;
  char*    fixedParamsDown;
  char*    correlParam;
  char*    output;
  ofstream outputFile;


  // ********************* Standard Input **********************
  int    numDimensions;
  int    numThermalization;
  int    numCycles;
  double stepLen;              // The step length of the Metropolis algorithm.
  int    allowSpinFlip;        // Boolean turns on(1) spin-flipping routines.
  int    quarterCusp;          // Boolean turns on(1) cusp=1/4 off (0).
  string thermalizationType;   // Normal or adaptive.
  double soughtAcceptance;     // What acceptance ratio we wish to have.
  int    numberSeekAcceptance; // Number of updates of the step length
                               // to get sought acceptance.
  int    varySeekWithRank;     // MPI option to vary the acceptance 
                               // ratio with the rank (process number).
  double varySeekWithRankStep; // How much we vary the acceptance.
  string vmcType;              // One at a time or Some.
  int    numberVmcRuns;        // Number of VMC runs.
  int    varianceOptimization; // Boolean 1=True, 0=False.
  double referenceEnergy;      // Reference energy for the variance-
                               // optimization. Updated between different VMC 
                               // moves.
  double deltaE;               // Quantity to allow both energy and variance 
                               // optimization.
  int    setWeightToUnity;     // Boolean 1=True, 0=False

  // Accosiated parameters
  int    twoD;


  // ****************** Electron Configuration ******************
  int numParticles;
  int numParticlesSpinUp;
  int numParticlesSpinDown;
  // Booleans indicating which electrons are allowed
  int up1s, up2s, up2px, up2py, up2pz;
  int up3s, up3px, up3py, up3pz, up4s;
  int down1s, down2s, down2px, down2py, down2pz;
  int down3s, down3px, down3py, down3pz, down4s;


  // ********************** Random Config ***********************
  string randomGenerator; // Either Ran0 or Ran1
  // int seed; The seed is given by the input file

  // The different rendom generator seeds
  int             initRanFlip;  // = seed - rank*3mill
  int             initRanMove;  // = seed - rank*3mill - 1 mill
  int             initRanMetro; // = seed - rank*3mill - 2 mill
  // References to the random generator
  Ref<Random2>    randomFlip;
  Ref<Random2>    randomMove;
  Ref<Random2>    randomMetro;


  // *************** Uni-Directional Configuration **************
  int    uniDirectionalMovement;       // Do we seek for minima in parameter
                                       // space (1=True, 0=False)?
  int    continueAfterUniDirectional;  // Whem minima is found, do we 
                                       // wish to make additional
                                       // sophisticated searches
                                       // (1=True, 0=False)?
  int    numberOfUniDirectionalMoves;  // Total number of sophisticated
                                       // minima searches.
  int    reduceLocalAreaBetweenMoves;  // Reduce the area in parameter-
                                       // space (1=True, 0=False)?
  double reduceLocalAreaByFraction;    // Reduce the area in parameter-
                                       // space by fraction.
  int    increaseNumCyclesBetweenMoves;// Increase the number of
                                       // cycles (1=True, 0=False)?
  int    increaseNumCyclesByFactor;    // Increase by factor.
  int    increaseNumThermalizationBetweenMoves; // Increase thermalization 
                                                // (1=True, 0=False)?
  int    increaseNumThermalizationByFactor;     // Increase by factor.

  // Indicator specifying whether or not minima is found
  int*   uniDirectionalIndicator;


  // *************************** Other *****************************
  int    numVariations;         // Total number of local variations 
                                // numSlaterVariations*numCorrelVariations
  double h;                     // Numberical difference (for calculating 
                                // derivatives)
  int*   paramIndex;            // Index used for initialization and updating 
                                // of alphaParam and betaParam in the 
                                // neighborhood of some central values for 
                                // the parameters.


  // *************** Slater-Determinant Parameters ***************
  string  orbitalType; // For example hydrogen, HF, etc.
  int     numAlpha;    // Number of variational (Slater) parameters (min 1).
  double* centralAlphaParams; // The central parameters (with no local 
                              // variation this is the parameter we use).
  int*    numAlphaVar; // Number of local variations for each iniviual
                       // variational parameter.
  double* alphaStep;   // The step (parameter difference) between  
                       // each local variation.
  double* alphaParam;  // Array containing all the different local 
                       // configurations in (Slater) parameter space.

  int     numSlaterVariations;  // Total number of local Slater variations.
  int     centerSlater;         // Index indicating which of the Slater 
                                // variations is the central one.
  void    createSlaterParams(); // Routine to initialize the Slater 
                                // determinant parameters.


  // ******************* Correlation Parameters *******************
  string  fBetaType;         // For example fNone, fBeta, fBetaLinear, etc.
  int     numBeta;           // Number of variational (correlation) 
                             // parameters (min 1).
  double* centralBetaParams; // The central parameters (with no local 
                             // variation this is the parameter we use).
  int*    numBetaVar;        // Number of local variations for each iniviual
                             // variational parameter.
  double* betaStep;          // The step (parameter difference) between  
                             // each local variation.
  
  double*    betaParam;            // Array containing all the different local 
                                   // configurations in (correlation) parameter 
                                   // space.
  int        numCorrelVariations;  // Total number of local correlation 
                                   // variations.
  int        centerCorrel;         // Index indicating which of the correlation
                                   // variations is the central one.
  fFunction* f;                    // Function set in accordance to the input
                                   // of fBetaType.
  void       createCorrelParams(); // Routine to initialize the correlation
                                   // parameters.
  void attachFParams(int _expBool);// Attach paramaters to given fFunction
  // Routines to create different fFunctions
  void createFBeta(int _expBool);
  void createFBeta2(int _expBool);
  void createFBeta3(int _expBool);

  void createFBeta2r2(int _expBool);
  void createFExtended(int _expBool);
  void createFNone();


  // ********************* Coordinates and Spin ********************
  int           currentParticle;// The current particle (being moved)
  int           otherParticle;  // The proposed particle to interchange spin 
                                // with (if spin flip is allowed)
  double*       coorArray;      // Cartesian coordinates of all coors.
  double*       _coorArray;      
  double*       trialCoorArray; // Cartesian coordinates of trialCoor.
  int           spinFlip;       // Boolean, is spin being proposed flipped.

  int*          spinArray;      // Array containing the different spins.
  CoorSpinDiff* coors;          // The coordinate objects.
  CoorSpinDiff* trialCoor;      // The trial coordinate.
  void          computeTrialPosition(); // Proposes a move of the current
                                        // particle.
  double        coorStep();     // Random walk of one coordinate.
  void          proposeFlip();  // Proposes an interchange of electron spin
                                // between current particle and (randomly)
                                // generated other particle.
  void          acceptTrialPosition(); // Accept the proposed move.
  void          rejectTrialPosition(); // Rejects the proposed move.
  void          resetPtr();            // Sets coorArray = _coorArray.
  void          setPositionToOrigin(); // Sets all coordinates equal zero.


  // ****************** Inter-electronic distances ******************
  Distance*     distance;     // Object that keeps track of the distances.
  DistanceDiff* distanceDiff; // Keeps track of the differentiated distances.
  void          createDistanceAndDistanceDiff(); // Creates the above objects.


  // ************************ Spin-Factors *************************
  // Object to impose the different cusp conditions for like-spin and opposite-
  // spin electrons, 1/4 and 1/2 respectively. Is turned on and off by the 
  // value of quarterCusp (on(1) cusp=1/4 off (0)).
  SpinFactors* spinFactors;
  void         createSpinFactors();




 // ****************************************************************
 // *                     PUBLIC ALGORITHMS                        *
 // ****************************************************************
 public:
  // Constructor: Input file name, prosess number, and number of MPI
  // processes
  Domain(char* _initFileName, int _rank, int _size);


  // ***************************** MPI *****************************
  int           getRank()                  {return rank;}
  int           getSize()                  {return size;}


  // ******************* Input and Output Files ********************
  ofstream*     getOutputFile()            {return &outputFile;}
  char*         getFixedParamsUp()        {return fixedParamsUp;}
  char*         getFixedParamsDown()      {return fixedParamsDown;}


  // *********************** Standard Input ************************
  int           getNumDimensions()         {return numDimensions;}
  int           getNumThermalization()     {return numThermalization;}
  int           getNumCycles()             {return numCycles;}
  double        getStepLen()               {return stepLen;}

  int           getAllowSpinFlip()         {return allowSpinFlip;}
  string        getThermalizationType()    {return thermalizationType;}
  double        getSoughtAcceptance()      {return soughtAcceptance;}
  int           getNumberSeekAcceptance()  {return numberSeekAcceptance;}

  int           getVarySeekWithRank()      {return varySeekWithRank;}
  double        getVarySeekWithRankStep()  {return varySeekWithRankStep;}
  string        getVmcType()               {return vmcType;}
  int           getVarianceOptimization()  {return varianceOptimization;}

  double        getReferenceEnergy()       {return referenceEnergy;}
  double        getDeltaE()                {return deltaE;}
  int           getSetWeightToUnity()      {return setWeightToUnity;}
  void          changeStepLen(int numSteps, int acceptedSteps, 
			      double soughtAcceptance);

  void          setReferenceEnergy(double E) {referenceEnergy=E;}


  // ******************* Electron Configuration ********************
  int getNumParticles()   {return numParticles;}
  int getUp1s()           {return up1s;}
  int getUp2s()           {return up2s;}
  int getUp2px()          {return up2px;}

  int getUp2py()          {return up2py;}
  int getUp2pz()          {return up2pz;}
  int getDown1s()         {return down1s;}
  int getDown2s()         {return down2s;}

  int getDown2px()        {return down2px;}
  int getDown2py()        {return down2py;}
  int getDown2pz()        {return down2pz;}


  // *********************** Random Config ************************
  Ref<Random2> getRandomMetro() {return randomMetro;}
  Ref<Random2> getRandomMove()  {return randomMove;}


  // **************** Uni-Directional Configuration ***************
  void increaseNumCycles(); 
  void increaseNumThermalization(); 
  void reduceLocalArea();
  int  getUniDirectionalMovement(){return uniDirectionalMovement;}

  int  getNumberVmcRuns()         {return numberVmcRuns;}
  int  getNumberOfUniDirectionalMoves() {return numberOfUniDirectionalMoves;}
  void initUniDirectionalIndicator();
  int  isMovementUniDirectional(double* alphaParams, double* betaParams);


  // *************************** Other *****************************
  int           getNumVariations()         {return numVariations;}
  double        getH()                     {return h;}


  // *************** Slater-Determinant Parameters ****************
  string  getOrbitalType()         {return orbitalType;}
  int     getNumAlpha()            {return numAlpha;} 
  int     getNumSlaterVariations() {return numSlaterVariations;}
  double* getAlphaParam(int i)     {return &(alphaParam[i*numAlpha]);}

  int     getCentralSlater()       {return centerSlater;}
  void    setCentralAlphaParam(double* param);
  void    calculateAlphaParamArray();


  // ******************* Correlation Parameters *******************
  int        getNumBeta()             {return numBeta;} 
  double*    getBetaParam(int i)      {return &(betaParam[i*numBeta]);}
  void       setCentralBetaParam(double* param);
  int        getCentralCorrel()       {return centerCorrel;}

  fFunction* getF()                   {return f;}
  void       calculateBetaParamArray();
  int        getNumCorrelVariations() {return numCorrelVariations;}


  // ******************** Coordinates and Spin *********************
  double*       getCoorArray()             {return coorArray;}
  CoorSpinDiff* getCoors();
  CoorSpinDiff* getTrialCoor();
  int*          getSpinArray()             {return spinArray;}

  int*          getSpinFlip()              {return &spinFlip;}
  int           getOtherParticle()         {return otherParticle;}
  void          setCoorsToOrigon();
  void          setCurrentParticle(int __currentParticle);

  void          setOtherParticle(int __otherParticle);
  void          setToNextParticle();
  void          init();
  void          initVMC();

  void          suggestMove();
  void          acceptMove();
  void          rejectMove();
  void          acceptThermalizedMove();

  void          rejectThermalizedMove();


  // ****************** Inter-electronic distances *****************
  Distance*     getDistance()              {return distance;}
  DistanceDiff* getDistanceDiff()          {return distanceDiff;}


  // ************************ Spin-Factors *************************
  SpinFactors*  getSpinFactors()           {return spinFactors;}


  // ********************** Potential Energy ***********************
  double getNucleusElectronPotential();
  double getInterElectronicPot() {return distance->getPotential();}


  // ************************** Summary ****************************
  void    initSummary();
  void    Summary();
};

#endif
\end{lstlisting}




% *************************************************************
% *                                                           *
% *                         DOMAIN.CPP                        *
% *                                                           *
% *************************************************************
\subsection{Domain.cpp}
\begin{lstlisting}
#include "Domain.h"

  // Constructor: Input file name, prosess number, and number of MPI
  // processes
Domain::Domain(char* initFileName, int _rank, int _size) {
  ifstream initIfile(initFileName); // Opening initIFile
  rank = _rank;
  size = _size;

  // ******************* Input and Output Files ********************
  standardInput         = new char[100];
  electronConfiguration = new char[100];
  randomConfig          = new char[100];
  uniDirectionalConfig  = new char[100];
  slaterParam           = new char[100];
  fixedParamsUp         = new char[100];
  fixedParamsDown       = new char[100];
  correlParam           = new char[100];
  output                = new char[100];
  // Reading from initIFile
  if (!(initIfile >> standardInput)) 
    cerr << "Error reading file: " << initFileName << endl;
  if (!(initIfile >> electronConfiguration))
    cerr << "Error reading file: " << initFileName << endl;
  if (!(initIfile >> randomConfig))
    cerr << "Error reading file: " << initFileName << endl;
  if (!(initIfile >> uniDirectionalConfig))
    cerr << "Error reading file: " << initFileName << endl;
  if (!(initIfile >> slaterParam))
    cerr << "Error reading file: " << initFileName << endl;
  if (!(initIfile >> fixedParamsUp))
    cerr << "Error reading file: " << fixedParamsUp << endl;
  if (!(initIfile >> fixedParamsDown))
    cerr << "Error reading file: " << fixedParamsDown << endl;
  if (!(initIfile >> correlParam))
    cerr << "Error reading file: " << initFileName << endl;
  if (!(initIfile >> output))
    cerr << "Error reading file: " << initFileName << endl;
  // Opening the files
  ifstream standardInputIfile(standardInput);
  ifstream electronConfigurationIfile(electronConfiguration);
  ifstream randomConfigIfile(randomConfig);
  ifstream uniDirectionalConfigIfile(uniDirectionalConfig);
  sprintf(output, "%s.run%d", output, rank);
  outputFile.open(output);


  // *********************** Standard Input ************************
  if (!(standardInputIfile >> numDimensions))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: numDimensions" << endl;
  if (!(standardInputIfile >> numThermalization))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: numThermalization" << endl;
  if (!(standardInputIfile >> numCycles))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: numCycles" << endl;
  if (!(standardInputIfile >> stepLen))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: stepLen" << endl;
  if (!(standardInputIfile >> allowSpinFlip))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: allowSpinFlip" << endl;
  if (!(standardInputIfile >> quarterCusp))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: quarterCusp" << endl;
  thermalizationType = new char[100];
  if (!(standardInputIfile >> thermalizationType))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: thermalizationType" << endl;
  if (!(standardInputIfile >> soughtAcceptance))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: soughtAcceptance" << endl;
  if (!(standardInputIfile >> numberSeekAcceptance))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: numberSeekAcceptance" << endl;
  if (!(standardInputIfile >> varySeekWithRank))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: varySeekWithRank" << endl;
  if (!(standardInputIfile >> varySeekWithRankStep))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: varySeekWithRankStep" << endl;
  vmcType = new char[100];
  if (!(standardInputIfile >> vmcType))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: vmcType" << endl;
  if (!(standardInputIfile >> numberVmcRuns))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: numberVmcRuns" << endl;
  if (!(standardInputIfile >> varianceOptimization))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: varianceOptimization" << endl;
  if (!(standardInputIfile >> referenceEnergy))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: referenceEnergy" << endl;
  if (!(standardInputIfile >> deltaE))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: deltaE" << endl;
  if (!(standardInputIfile >> setWeightToUnity))
    cerr << "Error reading file: " << standardInput 
	 << ". Couldn't read: setWeightToUnity" << endl;
  twoD                 = numDimensions*2;


  // ******************* Electron Configuration ********************
  if (!(electronConfigurationIfile >> numParticles))
    cerr << "Error reading file: " << electronConfiguration 
	 << ". Couldn't read: numParticles" << endl;
  if (!(electronConfigurationIfile >> numParticlesSpinUp ))
    cerr << "Error reading file: " << electronConfiguration 
	 << ". Couldn't read: numParticlesSpinUp" << endl;
  if (!(electronConfigurationIfile >> up1s >> up2s 
	>> up2px >> up2py >> up2pz >> up3s >> up3px 
	>> up3py >> up3pz >> up4s)) 
    cerr << "Error reading file: " << electronConfiguration 
	 << ". Couldn't read: up1s >> up2s >> up2px >> up2py >> up2pz" << endl;
  if (!(electronConfigurationIfile >> numParticlesSpinDown ))
    cerr << "Error reading file: " << electronConfiguration 
	 << ". Couldn't read: numParticlesSpinDown" << endl;
  if (!(electronConfigurationIfile >> down1s >> down2s 
	>> down2px >> down2py >> down2pz >> down3s 
	>> down3px >> down3py >> down3pz >> down4s))
    cerr << "Error reading file: " << electronConfiguration 
	 << ". Couldn't read: down1s >> down2s >> down2px >> down2py >> down2pz" << endl;


  // *********************** Random Config ************************
  randomGenerator = new char[100];
  if (!(randomConfigIfile >> randomGenerator))
    cerr << "Error reading file: " << randomConfig 
	 << ". Couldn't read: randomGenerator" <<  endl;
  int seed;
  if (!(randomConfigIfile >> seed))
    cerr << "Error reading file: " << randomConfig 
	 << ". Couldn't read: seed" <<  endl;
  if ((!seed < 0) & (seed > -1000000)) 
    cerr << "Error! The seed should be in the range (-1 000 000, -1)" << endl;
  else {
    initRanMove  = seed - rank*3000000;
    initRanFlip  = seed - rank*3000000 - 1000000;
    initRanMetro = seed - rank*3000000 - 2000000;
  }
  if ( randomGenerator=="Ran0") {
    randomMove           = new Ran0(initRanMove);
    randomFlip           = new Ran0(initRanFlip);
    randomMetro          = new Ran0(initRanMetro);
  }
  else if ( randomGenerator=="Ran1") {
    randomMove           = new Ran1(initRanMove);
    randomFlip           = new Ran1(initRanFlip);
    randomMetro          = new Ran1(initRanMetro);
  }
  else cerr << "Error input randomGenerator, only Ran0 and Ran1 implemented" 
	    << endl;


  // **************** Uni-Directional Configuration ***************
  if (!(uniDirectionalConfigIfile >> uniDirectionalMovement))
    cerr << "Error reading file: " << uniDirectionalConfig 
	 << ". Couldn't read: uniDirectionalMovement(1=True,0=False)" << endl;
  if (!(uniDirectionalConfigIfile >> numberOfUniDirectionalMoves))
    cerr << "Error reading file: " << uniDirectionalConfig 
	 << ". Couldn't read: numberOfUniDirectionalMoves" << endl;
  if (!(uniDirectionalConfigIfile >> reduceLocalAreaByFraction))
    cerr << "Error reading file: " << uniDirectionalConfig 
	 << ". Couldn't read: reduceLocalAreaByFraction" << endl;
  if (!(uniDirectionalConfigIfile >> increaseNumCyclesByFactor))
    cerr << "Error reading file: " << uniDirectionalConfig 
	 << ". Couldn't read: increaseNumCyclesByFactor" << endl;
  if (!(uniDirectionalConfigIfile >> increaseNumThermalizationByFactor))
    cerr << "Error reading file: " << uniDirectionalConfig 
	 << ". Couldn't read: increaseNumThermalizationByFactor" << endl;

  // *************************** Other *****************************
  paramIndex = new int[10];


  // *************** Slater-Determinant Parameters ***************
  createSlaterParams();


  // ******************* Correlation Parameters *******************
  createCorrelParams();


  // *************************** Other *****************************
  numVariations = numSlaterVariations * numCorrelVariations;
  h = 0.0001;   // Numerical differentiate parameter


  // ********************* Coordinates and Spin ********************
  coorArray      = new double[numDimensions*numParticles];
  trialCoorArray = new double[numDimensions];
  spinArray      = new int[numParticles + 1];
  coors          = new CoorSpinDiff[numParticles];

  trialCoor      = new CoorSpinDiff[1];
  setCoorsToOrigon();
  for (int i = 0; i <= numParticles; i++) spinArray[i]=1;
  for (int i = 0; i < numParticles; i++)
    coors[i].attach((coorArray + i*numDimensions), numDimensions, 
		    &spinArray[i], h);
  trialCoor[0].attach(trialCoorArray, numDimensions, 
		      &spinArray[numParticles], h);


  // **************** Uni-Directional Configuration ***************
  uniDirectionalIndicator = new int[2*(numAlpha+numBeta)];
  initUniDirectionalIndicator();


  // ************************ Spin-Factors *************************
  createSpinFactors();
  createDistanceAndDistanceDiff();
}



// *************************************************************
// *                       Standard Input                      *
// *************************************************************
//
// ************************ changeStepLen **********************
void Domain::changeStepLen(int numSteps, int acceptedSteps, 
			   double soughtAcceptance) {
  double acceptance = ((double) acceptedSteps)/numSteps;
  if (acceptance == 1) cerr << "Error in changing stepLen, either stepLen=0 or numThermalization small" << endl;
  else stepLen *= (1-soughtAcceptance)/(1-acceptance);
}



// *************************************************************
// *                Uni-Directional Configuration              *
// *************************************************************
//
// ********************** increaseNumCycles ********************
void Domain::increaseNumCycles() {
  numCycles*=increaseNumCyclesByFactor;

}

// *****************  increaseNumThermalization ****************
void Domain::increaseNumThermalization() {
  numThermalization*=increaseNumThermalizationByFactor;

}

// *********************** reduceLocalArea *********************
void Domain::reduceLocalArea() {
  for (int i=0; i<numAlpha; i++)
    alphaStep[i]*=reduceLocalAreaByFraction;
  for (int i=0; i<numBeta; i++)
    betaStep[i]*=reduceLocalAreaByFraction;
}

/// ***************** initUniDirectionalIndicator ***************
void Domain::initUniDirectionalIndicator() {
  int num = numAlpha + numBeta;
  for (int i=0; i<2*num; i++)
    uniDirectionalIndicator[i] = 1;
}

// ******************* isMovementUniDirectional ****************
int Domain::isMovementUniDirectional(double* alphaParams, double* betaParams) {
  // Update the uniDirectionalIndicator
  int num = numAlpha + numBeta;
  double small = 1e-15;
  for (int i=0; i<numAlpha; i++) {
    if ( alphaParams[i] <= centralAlphaParams[i] + small ) 
      uniDirectionalIndicator[i] = 0;
    if ( alphaParams[i] >= centralAlphaParams[i] - small) 
      uniDirectionalIndicator[i+num] = 0;
  }
  for (int i=0; i<numBeta; i++) {
    if ( betaParams[i] <= centralBetaParams[i] + small) 
      uniDirectionalIndicator[i+numAlpha] = 0;
    if ( betaParams[i] >= centralBetaParams[i] - small) 
      uniDirectionalIndicator[i+numAlpha+num] = 0;
  }

  // Here the test is performed
  int uni = 0;
  for (int i=0; i<2*num; i++)
    if ( uniDirectionalIndicator[i] != 0 ) uni = 1;

  return uni;
}



// *************************************************************
// *               Slater-Determinant Parameters               *
// *************************************************************
//
// ********************* createSlaterParams ********************
void Domain::createSlaterParams() {
  // Opening slaterParamIfile
  ifstream slaterParamIfile(slaterParam);
  //    cerr << "Error! Could not open file: " << slaterParam << endl;
  orbitalType = new char[100];
  if (!(slaterParamIfile >> orbitalType))
    cerr << "Error reading file: " << slaterParam 
	 << ". Couldn't read: orbitalType" << endl;
  if (!(slaterParamIfile >> numAlpha))
    cerr << "Error reading file: " << slaterParam 
	 << ". Couldn't read: numAlpha" << endl;
  if (numAlpha<1) cerr << "numAlpha must be at least 1" << endl;
  centralAlphaParams  = new double[numAlpha];
  numAlphaVar         = new int[numAlpha];
  alphaStep           = new double[numAlpha];
  for (int i=0; i<numAlpha; i++ ) {
    if (!(slaterParamIfile >> centralAlphaParams[i] >> 
	  numAlphaVar[i] >> alphaStep[i])) {
      cerr << "Error reading file: " << slaterParam 
	   << ". Couldn't read: centralAlphaParams[i] >>" 
	   << " numAlphaVar[i] >> alphaStep[i] (i=" << i << ")" << endl;
      cerr << "Possible missmach between numAlpha and" 
	   << " number of additional lines?" << endl;
    }
  }
  numSlaterVariations = 1;
  for (int i=0; i<numAlpha; i++)
    numSlaterVariations *= numAlphaVar[i];
  if ( (numSlaterVariations<1) || 
       ( !(odd(numSlaterVariations)) ) )
    cerr << "alpha#numVar must be odd and >0" << cerr << endl;
  alphaParam = new double[numAlpha*numSlaterVariations];
  calculateAlphaParamArray();
  centerSlater = centerOfOddIntegerMinusOne(numSlaterVariations);
}

// ****************** calculateAlphaParamArray *****************
void Domain::calculateAlphaParamArray() {
  for (int i=0; i<numAlpha; i++)
    centralAlphaParams[i] 
      -=  centerOfOddIntegerMinusOne(numAlphaVar[i]) * alphaStep[i];
  for (int i=0;i<numAlpha;i++) paramIndex[i]=0;
  bool increaseParam;
  int index;
  int j = 0;
  for (int i=0; i<numSlaterVariations; i++) {
    for (int k=0; k<numAlpha; k++) {
      alphaParam[j++] = centralAlphaParams[k];
    }
    index = 0;
    increaseParam = false;
    while (!increaseParam) {
      paramIndex[index] += 1;
      if (paramIndex[index] == numAlphaVar[index]) {
	centralAlphaParams[index] -= (numAlphaVar[index]-1)*alphaStep[index];
	paramIndex[index] = 0;
	index +=1;
      }
      else {
	centralAlphaParams[index] += alphaStep[index];
	increaseParam = true;
      }
    }
  }
  for (int i=0; i<numAlpha; i++)
    centralAlphaParams[i] += 
      centerOfOddIntegerMinusOne(numAlphaVar[i])*alphaStep[i];
}

// ******************** setCentralAlphaParam *******************
void Domain::setCentralAlphaParam(double* param) {
  copyArray(param, centralAlphaParams, numAlpha);
}



// *************************************************************
// *                   Correlation Parameters                  *
// *************************************************************
//
// ********************* createCorrelParams ********************
void Domain::createCorrelParams() {
  // Opening correlParamIfile
  ifstream correlParamIfile(correlParam);
  //    cerr << "Error! Could not open file: " << correlParam << endl;
  fBetaType = new char[100];
  if (!(correlParamIfile >> fBetaType))
    cerr << "Error reading file: " << correlParam 
	 << ". Couldn't read: fBetaType" << endl;
  if (!(correlParamIfile >> numBeta))
    cerr << "Error reading file: " << correlParam 
	 << ". Couldn't read: numBeta" << endl;
  centralBetaParams = new double[numBeta];
  numBetaVar    = new int[numBeta];
  betaStep      = new double[numBeta];
  for (int i=0; i<numBeta; i++ ) {
    if (!(correlParamIfile >> centralBetaParams[i] >> 
	  numBetaVar[i] >> betaStep[i])) {
      cerr << "Error reading file: " << correlParam 
	   << ". Couldn't read: centralBetaParams[i] >>" 
	   << " numBetaVar[i] >> betaStep[i] (i=" << i << ")" << endl;
      cerr << "Possible missmach between numBeta and" 
	   << " number of additional lines?" << endl;
    }
  }

  numCorrelVariations = 1;
  for (int i=0; i<numBeta; i++)
    numCorrelVariations *= numBetaVar[i];
  if ( (numCorrelVariations<1) || 
       ( !(odd(numCorrelVariations)) ) )
    cerr << "beta#numVar must be odd and >0" << cerr << endl;

  betaParam = new double[numBeta*numCorrelVariations];
  calculateBetaParamArray();
  centerCorrel = centerOfOddIntegerMinusOne(numCorrelVariations);

  if      ( fBetaType == "fNone" )        createFNone();
  else if ( fBetaType == "fBeta" )        createFBeta(1);
  else if ( fBetaType == "fBetaLinear" )  createFBeta(0);
  else if ( fBetaType == "fBeta2" )       createFBeta2(1);
  else if ( fBetaType == "fBeta3" )       createFBeta3(1);
  else if ( fBetaType == "fBeta2r2" )     createFBeta2r2(1);
  else if ( fBetaType == "fExtended" )    createFExtended(1);
  else if ( fBetaType == "fBeta2Linear" ) createFBeta2(0);
  else    cerr << "fBetaType not identified!" << endl;
}

// ******************* calculateBetaParamArray *****************
void Domain::calculateBetaParamArray() {
  for (int i=0; i<numBeta; i++)
    centralBetaParams[i] 
      -= centerOfOddIntegerMinusOne(numBetaVar[i]) * betaStep[i];
  for (int i=0;i<numBeta;i++) paramIndex[i]=0;
  bool increaseParam;
  int index;
  int j = 0;
  for (int i=0; i<numCorrelVariations; i++) {
    for (int k=0; k<numBeta; k++) {
      betaParam[j++] = centralBetaParams[k];
    }
    index = 0;
    increaseParam = false;
    while (!increaseParam) {
      paramIndex[index] += 1;
      if (paramIndex[index] == numBetaVar[index]) {
	centralBetaParams[index] -= (numBetaVar[index]-1)*betaStep[index];
	paramIndex[index] = 0;
	index +=1;
      }
      else {
	centralBetaParams[index] += betaStep[index];
	increaseParam = true;
      }
    }
  }
  for (int i=0; i<numBeta; i++)
    centralBetaParams[i] += 
      centerOfOddIntegerMinusOne(numBetaVar[i]) * betaStep[i];
}

// ******************** setCentralBetaParam ********************
void Domain::setCentralBetaParam(double* param) {
  copyArray(param, centralBetaParams, numBeta);
}

// ************************ attachFParams **********************
void Domain::attachFParams(int _expBool) {
  for (int i=0; i<numCorrelVariations; i++)
    f[i].attach(numBeta, &(betaParam[i*numBeta]),_expBool);
}

// ************************* createFNone ***********************
void Domain::createFNone() {
  if (numBeta != 1) cerr << "Need numBeta=1 to create fNone!" << endl;
  numCorrelVariations = 1;
  f = new fNone[1];
  attachFParams(0);
}

// ************************* createFBeta ***********************
void Domain::createFBeta(int _expBool) {
  if (numBeta != 1) 
    cerr << "Could not create fBeta, numBeta must be 1!" << endl;
  else {
    f = new fBeta[numCorrelVariations];
    attachFParams(_expBool);
  }
}

// ************************ createFBeta2 ***********************
void Domain::createFBeta2(int _expBool) {
  if (numBeta != 2) 
    cerr << "Could not create fBeta2, numBeta must be 2!" << endl;
  else {
    f = new fBeta2[numCorrelVariations];
    attachFParams(_expBool);
  }
}

// ************************ createFBeta3 ***********************
void Domain::createFBeta3(int _expBool) {
  if (numBeta != 3) 
    cerr << "Could not create fBeta3, numBeta must be 3!" << endl;
  else {
    f = new fBeta3[numCorrelVariations];
    attachFParams(_expBool);
  }
}

// *********************** createFBeta2r2 **********************
void Domain::createFBeta2r2(int _expBool) {
  if (numBeta != 2) 
    cerr << "Could not create fBeta2r2, numBeta must be 2!" << endl;
  else {
    f = new fBeta2r2[numCorrelVariations];
    attachFParams(_expBool);
  }
}

// ********************** createFExtended **********************
void Domain::createFExtended(int _expBool) {
  if (numBeta != 8) 
    cerr << "Could not create fExtended, numBeta must be 8!" << endl;
  else {
    f = new fExtended[numCorrelVariations];
    attachFParams(_expBool);
  }
}



// *************************************************************
// *                 Inter-electronic distances                *
// *************************************************************
//
// **************** createDistanceAndDistanceDiff **************
void Domain::createDistanceAndDistanceDiff() {
  distance        = new Distance;
  distance->attach(coors, trialCoor, 
		   numParticles);
  distanceDiff    = new DistanceDiff[numDimensions];
  for (int i=0; i<numDimensions; i++)
      distanceDiff[i]
	.attach(coors, trialCoor, numParticles, h,i); 
  
}



// *************************************************************
// *                    Coordinates and Spin                   *
// *************************************************************
//
// ********************* setCurrentParticle ********************
void Domain::setCurrentParticle(int __currentParticle) {
  currentParticle = __currentParticle;
  _coorArray      = (coorArray + currentParticle*numDimensions);
  spinFactors->setCurrentParticle(currentParticle);
  distance->setCurrentParticle(currentParticle);
  for (int i=0; i< numDimensions; i++)
    distanceDiff[i].setCurrentParticle(currentParticle);
}

// ********************** setOtherParticle *********************
void Domain::setOtherParticle(int __otherParticle) {
  otherParticle  = __otherParticle;
  spinFactors->setOtherParticle(otherParticle);
}

// ********************** setToNextParticle ********************
void Domain::setToNextParticle() {
  if (++currentParticle == numParticles) {
    currentParticle = 0;
    resetPtr();
  }
  else
    _coorArray += numDimensions;
  spinFactors->setToNextParticle();
  distance->setToNextParticle();
  for (int i=0; i< numDimensions; i++)
    distanceDiff[i].setToNextParticle();
}

// **************************** init ***************************
void Domain::init() {
  setCurrentParticle(0);
  for (int i = 0; i <= numParticles; i++)
    spinArray[i]=1;

  for (int i = 0; i < numParticles; i++) {
    setPositionToOrigin();
    computeTrialPosition();
    acceptTrialPosition();
    if (currentParticle >= numParticlesSpinUp)
      coors[currentParticle].flipSpin();
    coors[currentParticle].calculateR();
    setToNextParticle();
  }
  spinFactors->init();
  spinFactors->setOtherParticle(0);
  distance->initialize();
}

// ************************** initVMC **************************
void Domain::initVMC() {
  setCurrentParticle(0);
  distance->initialize();
  for (int i = 0; i < numDimensions; i++)
    distanceDiff[i].initialize();
}

// ************************ suggestMove ************************
void Domain::suggestMove() {
  computeTrialPosition();
  distance->suggestMove();
  proposeFlip();
}

// ************************ acceptMove *************************
void Domain::acceptMove() {
  for (int i = 0; i < numDimensions; i++)
    distanceDiff[i].suggestMove();
  acceptThermalizedMove();
  for (int i = 0; i < numDimensions; i++)
    distanceDiff[i].acceptMove();
}

// ************************ rejectMove *************************
void Domain::rejectMove() {
  rejectThermalizedMove();
 for (int i = 0; i < numDimensions; i++)
    distanceDiff[i].rejectMove();
}

// ******************* acceptThermalizedMove *******************
void Domain::acceptThermalizedMove() {
  acceptTrialPosition();
  distance->acceptMove();
}


// ******************* rejectThermalizedMove *******************
void Domain::rejectThermalizedMove() {
  rejectTrialPosition();
  distance->rejectMove();
}

// ************************ proposeFlip ************************
void Domain::proposeFlip() {
  if (allowSpinFlip) {
    setOtherParticle ( (int) (randomFlip().getNum()*numParticles) );
    spinFlip = (*(spinArray+currentParticle) != *(spinArray+otherParticle));
  }
  if (quarterCusp) {
    if (spinFlip) spinFactors->calculateFlipFactors();
    else spinFactors->calculateNoFlipFactors();
  }
}

// ************************** resetPtr *************************
void Domain::resetPtr() {
  _coorArray = coorArray;
}

// ******************** computeTrialPosition *******************
void Domain::computeTrialPosition() {
  for (int i = 0; i < numDimensions; i++) {
    trialCoorArray[i] = _coorArray[i] + coorStep();
  }
  trialCoor[0].spin() = coors[currentParticle].spin();
  trialCoor[0].calculateR();
  trialCoor[0].calculateDiffs();
}

// ******************** acceptTrialPosition ********************
void Domain::acceptTrialPosition() {
  for (int i = 0; i < numDimensions; i++)
    _coorArray[i] = trialCoorArray[i];
  coors[currentParticle].copy(trialCoor);
}

// ******************** rejectTrialPosition ********************
void Domain::rejectTrialPosition() {
}

// ******************** setPositionToOrigin ********************
void Domain::setPositionToOrigin() {
   for (int i = 0; i < numDimensions; i++)
    _coorArray[i] = 0;
   coors[currentParticle].calculateR();
}

// ************************** getCoors *************************
CoorSpinDiff* Domain::getCoors() {
  return coors;
}

// ************************ getTrialCoors **********************
CoorSpinDiff* Domain::getTrialCoor() {
  return trialCoor;
}

// *************************** coorStep ************************
double Domain::coorStep() {
  return (stepLen * (randomMove().getNum() - 0.5)/ numParticles);
}


// ********************** setCoorsToOrigon *********************
void Domain::setCoorsToOrigon() {
  for (int i=0; i<numDimensions*numParticles; i++)
    coorArray[i]=0;

  for (int i=0; i<numDimensions; i++)
    trialCoorArray[i]=0;
}


// *************************************************************
// *                      Spin-Factors                         *
// *************************************************************
//
// ******************** createSpinFactors **********************
void Domain::createSpinFactors() {
  spinFactors = new SpinFactors;
  spinFlip    = 0;
  spinFactors->allocate(numParticles, spinArray);
  spinFactors->setQuarterCusp(quarterCusp);
  spinFactors->init();
}


// *************************************************************
// *                     Potential Energy                      *
// *************************************************************
//
// ***************** getNucleusElectronPotential ***************
double Domain::getNucleusElectronPotential() {
  double nucleusElectronPotential = 0;
  for (int i=0; i<numParticles; i++)
    nucleusElectronPotential -= 1/coors[i].r();
  return ( (double) numParticles )*nucleusElectronPotential;
}


// *************************************************************
// *                          Summary                          *
// *************************************************************
//
// ************************* initSummary ***********************
void Domain::initSummary() {
  outputFile << "!!!!!!!!!!!!   INITIAL CONFIGURATION   !!!!!!!!!!!!!!!!!!" 
	     << endl
	     << "numDimensions          " << numDimensions << endl
	     << "numParticles           " << numParticles << endl
	     << "numParticlesSpinUp     " << numParticlesSpinUp << endl
	     << "spinUpConfig           [ "
	     << up1s << " " << up2s << " " << up2px << " " << up2py 
	     << " " << up2pz << " ]" << endl
	     << "numParticlesSpinDown   " << numParticlesSpinDown << endl
	     << "spinDownConfig         [ "
	     << down1s << " " << down2s << " " << down2px << " " << down2py 
	     << " " << down2pz << " ]" << endl
	     << "randomGenerator        " << randomGenerator << endl
	     << "initRanMove/Flip/Metro [ " << initRanMove << " " 
	     << initRanFlip << " " << initRanMetro << " ]\n"
	     << "orbitalType            " << orbitalType << endl
	     << "fBetaType              " << fBetaType << endl;
  if (quarterCusp) 
    outputFile << "Quarter-cusp for like-spin particles turned on!\n";
  else 
    outputFile << "Quarter-cusp for like-spin particles turned off!\n";
  if (allowSpinFlip) 
    outputFile << "Spin-flip turned on!\n";
  else 
    outputFile << "Spin-flip turned off!\n";
  outputFile << "Thermalization set to type '" << thermalizationType 
	     << "', and VMC type set\n" << "to '" << vmcType << "'.\n";
  if (uniDirectionalMovement) 
    outputFile << "The minima in parameter space "
	       << "will be sought (uniDirectionalMovement=1).\n"
	       << "There will be " << numberOfUniDirectionalMoves 
	       << " unidirectional moves. " 
	       << "One unidirectional move will consist\n" 
	       << "of maximum " << numberVmcRuns << " VMC runs.\n"
	       << "In-between each unidirectional move" 
	       << " the number of cycles will be increased by \n" 
	       << "a factor " << increaseNumCyclesByFactor 
	       << ", and the number" 
	       << " of thermalization by a factor " 
	       << increaseNumThermalizationByFactor << ". The "
	       << "variational \nparameters step length will be reduced" 
	       << " by fraction " << reduceLocalAreaByFraction << ".\n";
  else outputFile << numberVmcRuns << " VMC runs (with differing" 
		  << " seeds) will be conducted.\n";
  outputFile << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" 
	     << endl;
}

// **************************** Summary ****************************
void Domain::Summary() {
  outputFile << "*********************************************************" 
	     << endl
	     << "Summary of domain:" << endl
	     << "     numThermalization  " << numThermalization << endl
	     << "     numCycles          " << numCycles << endl
	     << "     stepLen            " << stepLen << endl
	     << "     centralAlphaParams [ ";

  for (int i=0; i<numAlpha; i++) 
    outputFile << centralAlphaParams[i]  << " ";

  outputFile << "]" << endl
	     << "     numAlphaVar        [ ";

  for (int i=0; i<numAlpha; i++) outputFile << numAlphaVar[i]  << " ";
  outputFile << "]" << endl
	     << "     alphaStep          [ ";
  for (int i=0; i<numAlpha; i++) outputFile << alphaStep[i]  << " ";
  outputFile << "]" << endl
	     << "     centralBetaParams  [ ";
  for (int i=0; i<numBeta; i++) outputFile << centralBetaParams[i]  << " ";
  outputFile << "]" << endl
	     << "     numBetaVar         [ ";
  for (int i=0; i<numBeta; i++) outputFile << numBetaVar[i]  << " ";
  outputFile << "]" << endl
	     << "     betaStep           [ ";
  for (int i=0; i<numBeta; i++) outputFile << betaStep[i]  << " ";
  outputFile << "]" << endl
	     << "*********************************************************" 
	     << endl;
}
\end{lstlisting}
\newpage






% *************************************************************
% *                                                           *
% *                           COOR.H                          *
% *                                                           *
% *************************************************************
\subsection{Coor.h}
\begin{lstlisting}
#ifndef Coor_IS_INCLUDED
#define Coor_IS_INCLUDED

#include <iostream>
#include <cmath>
using namespace std;


// ****************************************************************
// *                            COOR                              *
// ****************************************************************
class Coor {

 protected:
  double* x;    // Cartesian coordinates
  double* _x;   // Pointer to current coordinate
  int     len;  // Number of cartesian dimensions


 public:
  Coor(double* x, int _len);
  Coor() {}
  virtual void           attach(double* __x, int _len);
  inline virtual void    resetPtr()          {_x = x;}
  inline virtual double& operator()()        {return *_x;}
  inline virtual double& operator()(int num) {return x[num];}
  inline virtual void    operator++(int)     {_x++;}
  virtual int            getLen()            {return len;}
};


// ****************************************************************
// *                           COORR                              *
// ****************************************************************
class CoorR : public Coor {

 protected:
  double _r;
  int    rIsCalculated;

 public:
  CoorR(double* x, int _len);
  CoorR();  
  virtual void    attach(double* x, int _len);
  inline virtual double& r()      {return _r;}
  inline virtual void    calculateR();
};


// ****************************************************************
// *                          COORSPIN                            *
// ****************************************************************
class CoorSpin : public CoorR {

 protected:
  int* _spin;

 public:
  CoorSpin(double* x, int _len, int* __spin);
  CoorSpin() {}
  virtual void attach(double* x, int _len, int* __spin);
  inline virtual int& spin()     {return *_spin;}
  inline virtual int  flipSpin() {return (*_spin *= -1);}

};


// ****************************************************************
// *                        COORSPINDIFF                          *
// ****************************************************************
class CoorSpinDiff : public CoorSpin {

 protected:
  // rDiff[0]             = sqrt( (x+h)^2 + y^2     + ... )
  // rDiff[1]             = sqrt( x^2     + (y+h)^2 + ... )
  // ...
  // rDiff[numDimensions] = sqrt( (x-h)^2 + y^2     + ... )
  // ...
  double* rDiff;
  double h, twoh;
  int twoLen;

 public:
  CoorSpinDiff(double* x, int _len, int* __spin, double _h);
  CoorSpinDiff() {}
  virtual void attach(double* x, int _len, int* __spin, double _h);
  virtual void calculateDiffs();
  // rdiff(0)             = sqrt( (x+h)^2 + y^2     + ... )
  // rdiff(1)             = sqrt( x^2     + (y+h)^2 + ... )
  // ...
  // rdiff(numDimensions) = sqrt( (x-h)^2 + y^2     + ... )
  // ...
  inline virtual double& r()           {return _r;}
  inline virtual double& r(int number) {return rDiff[number];}
  inline virtual double& operator()()  {return *_x;}
  inline virtual double& operator()(int num);
  inline virtual double  operator()(int num, int currentNr);
  inline virtual double* getX()        {return x;}
  inline virtual void    copy(CoorSpinDiff* copyCoor);
  inline virtual void    calculateR();
  virtual double rdiff(int currentNr)  {return rDiff[currentNr];}
};

#endif
\end{lstlisting}


% *************************************************************
% *                                                           *
% *                          COOR.CPP                         *
% *                                                           *
% *************************************************************
\subsection{Coor.cpp}
\begin{lstlisting}
#include "Coor.h"

// ****************************************************************
// *                            COOR                              *
// ****************************************************************
Coor::Coor(double* __x, int _len) : x(__x), len(_len) {
  resetPtr();
}

void Coor::attach(double* __x, int _len) {
  x   = __x;
  len = _len;
  resetPtr();
}


// ****************************************************************
// *                           COORR                              *
// ****************************************************************
CoorR::CoorR(double* __x, int _len) : Coor(__x, _len) {
  rIsCalculated = 0;
}

CoorR::CoorR() : Coor() {
  rIsCalculated = 0;
}

void CoorR::attach(double* __x, int _len) {
  Coor::attach(__x, _len);
}

void CoorR::calculateR() {
  _r = x[0]*x[0];
  for (int i = 1; i < len; i++)
    _r += (x[i]*x[i]);
  _r = sqrt(_r);
}


// ****************************************************************
// *                          COORSPIN                            *
// ****************************************************************
CoorSpin::CoorSpin(double* __x, int _len, int* __spin) : CoorR(__x, _len) {
  _spin = __spin;
}

void CoorSpin::attach(double* __x, int _len, int* __spin) {
  CoorR::attach(__x, _len);
  _spin = __spin;
}


// ****************************************************************
// *                        COORSPINDIFF                          *
// ****************************************************************
CoorSpinDiff::CoorSpinDiff(double* __x, int _len, int* __spin, double _h) : CoorSpin(__x, _len, __spin) {
  h = _h;
  twoh = 2*h;
  rDiff = new double[len*2];
}

void CoorSpinDiff::attach(double* __x, int _len, int* __spin, double _h) {
  CoorSpin::attach(__x, _len, __spin);
  h = _h;
  twoh = 2*h;
  twoLen = 2*len;
  rDiff = new double[twoLen + 1];
}

void CoorSpinDiff::calculateR() {
  _r = x[0]*x[0];
  for (int i = 1; i < len; i++)
    _r += (x[i]*x[i]);
  _r = sqrt(_r);
  rDiff[twoLen] = _r;
}

void CoorSpinDiff::calculateDiffs() {
  double rTemp;
  for (int i=0; i<len; i++) {

    x[i] += h;
    rTemp = x[0]*x[0];
    for (int j = 1; j < len; j++)
      rTemp += (x[j]*x[j]);
    rDiff[i] = sqrt(rTemp);

    x[i] -= twoh;
    rTemp = x[0]*x[0];
    for (int j = 1; j < len; j++)
      rTemp += (x[j]*x[j]);
    rDiff[i+len] = sqrt(rTemp);

    x[i] += h;
  }
}

double& CoorSpinDiff::operator()(int num) {
  return x[num];
}

double CoorSpinDiff::operator()(int num, int currentNumber) {
  return x[num] + ((currentNumber == num) - (currentNumber == num+len))*h; 
}

void CoorSpinDiff::copy(CoorSpinDiff* copyCoor) {
  _r = copyCoor->r();
  for (int i=0; i <= twoLen; i++)
    rDiff[i] = copyCoor->rdiff(i);
}
\end{lstlisting}



\newpage



% *************************************************************
% *                                                           *
% *                       DISTANCE.H                          *
% *                                                           *
% *************************************************************
\subsection{Distance.h}
\begin{lstlisting}
#ifndef Distance_IS_INCLUDED
#define Distance_IS_INCLUDED

#include "../Coor/Coor.h"
#include <blitz/array.h>
#include <cmath>
using namespace blitz;

#ifndef sqr_IS_INCLUDED
#define sqr_IS_INCLUDED
inline double sqr(double x) {return x*x;};
#endif

// ****************************************************************
// *                          DISTANCE                            *
// ****************************************************************
class Distance {

 protected:
  CoorSpinDiff* Coordinate;
  CoorSpinDiff* TrialCoordinate;
  int numParticles;     // Number of particles
  int Nm1;              // numParticles - 1
  int numDimensions;    // Number of dimension
  // Array of Upper matrix composed of the distance between 
  // particle i and j
  Array<double, 2> interElectronicDistances;
  // The (new) distance from the current particle to the other particles
  Array<double, 1> trialColumn;
  Array<double, 1> trialRow;
  int currentParticle;  // This is the particle that currently is 
                        // (proposed) moved

 public:
  Distance() {}
  void    attach(CoorSpinDiff* _Coordinate, CoorSpinDiff* _TrialCoordinate, 
		 int _numParticles);
  void    initialize();
  void    setToNextParticle();
  void    setCurrentParticle(int _currentParticle);
  void    suggestMove();
  void    acceptMove();
  void    rejectMove() {}
  double  getPotential();
  Array<double, 2> getInterElectronicDistances() 
    {return interElectronicDistances;}
  Array<double, 1> getTrialColumn() {return trialColumn;}
  Array<double, 1> getTrialRow()    {return trialRow;}
};

// ****************************************************************
// *                        DISTANCEDIFF                          *
// ****************************************************************
class DistanceDiff : public Distance {
 protected:
  double h;          // Differential parameter, 
                     // dr/dx ~= ( r(x+h) - r(x-h) )/2h
  double twoh;       // 2*h
  int differentiate; // Which dimension (x=0, y=1 or z=2 in three dim.) 
                     // to be differentiated


 public:
  DistanceDiff() {}
  void attach(CoorSpinDiff* _Coordinate, CoorSpinDiff* _TrialCoordinate, 
	      int _numParticles, double _h, int _differentiate);
  void initialize();
  void suggestMove();
  void acceptMove();
  void rejectMove() {}
};

#endif
\end{lstlisting}



% *************************************************************
% *                                                           *
% *                      DISTANCE.CPP                         *
% *                                                           *
% *************************************************************
\subsection{Distance.cpp}
\begin{lstlisting}
#include "Distance.h"

// ****************************************************************
// *                          DISTANCE                            *
// ****************************************************************
// ************************* Distance ************************
// Class to monitor inter-electronic distances:
//
// Here the interElectronicDistances matrix is given by:
//                    
//                  |  0  r01 r02 ... r0(N-1)  |
//                  | r01  0  r12 ... r1(N-1)  |
//                  | r02 r12  0  ... r2(N-1)  |
//                  |  .         .      .      |
//                  |  .           .    .      |
//                  |  .             .  .      |
//                  |  .           r(N-2)(N-1) |
//                  | r0(N-1) .  .  .   0      |
//                    
void Distance::attach(CoorSpinDiff* _Coordinate, 
		      CoorSpinDiff* _TrialCoordinate, 
		      int _numParticles) {
  Coordinate      = _Coordinate; 
  TrialCoordinate = _TrialCoordinate;
  numParticles    = _numParticles; 
  Nm1             = numParticles - 1;
  numDimensions   = (*Coordinate).getLen();

  interElectronicDistances.resize(numParticles, numParticles);
  trialColumn.resize(numParticles);
  trialRow.resize(numParticles);
}

void Distance::initialize() {
  CoorSpinDiff* temp;
  temp = TrialCoordinate;
  setCurrentParticle(0);
  for (int i=0; i<numParticles; i++) {
    TrialCoordinate = &Coordinate[i];
    suggestMove();
    acceptMove();
    setToNextParticle();
  }
  TrialCoordinate = temp;
}


void Distance::setToNextParticle() {
 currentParticle++;
 if (currentParticle == numParticles) currentParticle=0;
}


void Distance::setCurrentParticle(int _currentParticle) {
  currentParticle = _currentParticle;
}


void Distance::suggestMove()
{
  for (int i=0; i<numParticles; i++) {
    double difference = sqr(Coordinate[i]()-(*TrialCoordinate)());
    for (int j=1; j<numDimensions; j++) {
      Coordinate[i]++; (*TrialCoordinate)++;
      difference += sqr(Coordinate[i]()-(*TrialCoordinate)());
    }
    Coordinate[i].resetPtr(); (*TrialCoordinate).resetPtr();
    trialColumn(i) = trialRow(i) = sqrt(difference);
  }
  trialColumn(currentParticle) = trialRow(currentParticle) = 0;
  
}

void Distance::acceptMove()
{
  Range N(0,Nm1);
  interElectronicDistances( currentParticle, N )  = trialColumn( N );
  interElectronicDistances( N , currentParticle ) = trialRow( N );
}

double Distance::getPotential()
{
  double potential = 0;
  for (int i=0; i<Nm1; i++)
    for (int j=i+1; j<numParticles; j++) 
      potential += 1/interElectronicDistances(i, j);
  return potential;
}



// ****************************************************************
// *                        DISTANCEDIFF                          *
// ****************************************************************
//
//
// Class to monitor the values used for numerical derivation of the 
// Jastrow-factor:
//                    dfij/dxi     ~= ( fij(xi+h) - fij(xi-h))/2h
// and:
//                    d^2fij/dxi^2 ~= ( fij(xi+h) + fij(xi-h) -2fij)/h^2
//
// ie. we need the values rij(xi+h) and rij(xi-h). Here xi is the either 
// x,y,z (for the three dimensional problem) of particle i.
// The relation:
//                    drij/dxi = - drij/dxj
// Implies:
//                    rij(xi+h) = rij(xj-h)
//
// Utilizing this relation, we need only to calculate one of the two.
// Here the rij matrix, given by:
//                    
//        | 0         r01(x1+h) r02(x2+h) ... r0(N-1)(x(N-1)+h)   |
//        | r01(x0+h)    0      r12(x2+h) ... r1(N-1)(x(N-1)+h)   |
//        | r02(x0+h) r12(x2+h)     0     ... r2(N-1)(x(N-1)+h)   |
//        | .            .                            .           |
//        | .            .                            .           |
//        | .            .                            .           |
//        | .            .                  r(N-2)(N-1)(x(N-1)+h) |
//        | r0(N-1)(x0+h)          r(N-2)(N-1)(x(N-2)+h)    0     |
void DistanceDiff::attach(CoorSpinDiff* _Coordinate, 
			  CoorSpinDiff* _TrialCoordinate, 
			  int _numParticles, double _h, 
			  int _differentiate) {
  Coordinate      = _Coordinate; 
  TrialCoordinate = _TrialCoordinate;
  numParticles    = _numParticles; 
  Nm1             = numParticles - 1;

  numDimensions   = (*Coordinate).getLen();
  h               = _h;
  twoh            = 2*h;
  differentiate   = _differentiate;   

  interElectronicDistances.resize(numParticles, numParticles);
  trialColumn.resize(numParticles);
  trialRow.resize(numParticles);
}

void DistanceDiff::initialize() {
  CoorSpinDiff* temp;
  temp = TrialCoordinate;
  setCurrentParticle(0);
  for (int i=0; i<numParticles; i++) {
    TrialCoordinate = &Coordinate[i];
    suggestMove();
    acceptMove();
    setToNextParticle();
  }
  TrialCoordinate = temp;
}

void DistanceDiff::suggestMove()
{
  (*TrialCoordinate)(differentiate)-=h;
  for (int i=0; i<currentParticle; i++) {
    double difference = sqr(Coordinate[i]()-(*TrialCoordinate)());
    for (int j=1; j<numDimensions; j++) {
      Coordinate[i]++; (*TrialCoordinate)++;
      difference += sqr(Coordinate[i]()-(*TrialCoordinate)());
    }
    Coordinate[i].resetPtr(); (*TrialCoordinate).resetPtr();
    trialRow(i) = sqrt(difference);
  }
  for (int i=currentParticle+1; i<numParticles; i++) {
    double difference = sqr(Coordinate[i]()-(*TrialCoordinate)());
    for (int j=1; j<numDimensions; j++) {
      Coordinate[i]++; (*TrialCoordinate)++;
      difference += sqr(Coordinate[i]()-(*TrialCoordinate)());
    }
    Coordinate[i].resetPtr(); (*TrialCoordinate).resetPtr();
    trialRow(i) = sqrt(difference);
  }

  (*TrialCoordinate)(differentiate)+=twoh;
  for (int i=0; i<currentParticle; i++) {
    double difference = sqr(Coordinate[i]()-(*TrialCoordinate)());
    for (int j=1; j<numDimensions; j++) {
      Coordinate[i]++; (*TrialCoordinate)++;
      difference += sqr(Coordinate[i]()-(*TrialCoordinate)());
    }
    Coordinate[i].resetPtr(); (*TrialCoordinate).resetPtr();
    trialColumn(i) = sqrt(difference);
  }
  for (int i=currentParticle+1; i<numParticles; i++) {
    double difference = sqr(Coordinate[i]()-(*TrialCoordinate)());
    for (int j=1; j<numDimensions; j++) {
      Coordinate[i]++; (*TrialCoordinate)++;
      difference += sqr(Coordinate[i]()-(*TrialCoordinate)());
    }
    Coordinate[i].resetPtr(); (*TrialCoordinate).resetPtr();
    trialColumn(i) = sqrt(difference);
  }
  (*TrialCoordinate)(differentiate)-=h;
  trialRow(currentParticle) = 0;
  trialColumn(currentParticle) = 0;
}

void DistanceDiff::acceptMove()
{
  Range N(0,Nm1);
  interElectronicDistances( currentParticle, N )  = trialColumn( N );
  interElectronicDistances( N, currentParticle ) = trialRow( N );
}
\end{lstlisting}



\newpage



% *************************************************************
% *                                                           *
% *                           REF.H                           *
% *                                                           *
% *************************************************************
\subsection{Ref.h}
\begin{lstlisting}
#ifndef Ref_IS_INCLUDED
#define Ref_IS_INCLUDED

#ifdef _DEBUG_
#define REF(TYPE) RefFund<TYPE>
#endif

#ifndef _DEBUG_
#define REF(TYPE) TYPE*
#endif

// ****************************************************************
// *                             REF                              *
// ****************************************************************
template <class type>
class Ref {

 protected:
  type* item;

 public:
  Ref() {}
  Ref(type& _item)            {item = &_item;}
  void attach(type& _item)    {item = &_item;}
  void operator=(type& _item) {item = &_item;}
  void operator=(type* _item) {item =  _item;}
  inline type& operator()()   {return *item;}
  inline type* getPtr()       {return item;}
};

// ****************************************************************
// *                           REFFUND                            *
// ****************************************************************
template <class type>
class RefFund : public Ref<type> {

 public:
  void operator=(type& _item) {item = &_item;}
  void operator=(type* _item) {item =  _item;}
  inline type& operator()()   {return *item;}
  inline operator type& ()    {return *item;}  

};

#endif
\end{lstlisting}

\newpage



% *************************************************************
% *                                                           *
% *                         RANDOM.H                          *
% *                                                           *
% *************************************************************
\subsection{Random.h}
\begin{lstlisting}
#ifndef Random2_IS_INCLUDED
#define Random2_IS_INCLUDED

#include <iostream>
#include <cstdio>

// ****************************************************************
// *                          RANDOM2                             *
// ****************************************************************
class Random2 {
 protected:
  long dummy;

 public:
  Random2(long seed) : dummy(seed) {}
  virtual ~Random2() {}
  virtual double getNum(void) {return 0;}
  virtual void   demo(int num, FILE* stream);
};

// ****************************************************************
// *                            RAN0                              *
// ****************************************************************
class Ran0 : public Random2 {
 public:
  Ran0(long seed) : Random2(seed) {}
  double getNum(void);
};

// ****************************************************************
// *                            RAN1                              *
// ****************************************************************
class Ran1 : public Random2 {
 public:
  Ran1(long seed) : Random2(seed) {}
  double getNum(void);
};

#endif
\end{lstlisting}


% *************************************************************
% *                                                           *
% *                         RANDOM.CPP                        *
% *                                                           *
% *************************************************************
\subsection{Random.cpp}
\begin{lstlisting}
#include "Random.h"

// ****************************************************************
// *                          RANDOM2                             *
// ****************************************************************
void Random2::demo(int num, FILE* stream) {
  for (int i = 0; i < num; i++)
    fprintf(stream, "%f\n", getNum());
}

// ****************************************************************
// *                            RAN0                              *
// ****************************************************************
#define IA 16807
#define IM 2147483647
#define AM (1.0/IM)
#define IQ 127773
#define IR 2836
#define MASK 123459876
double Ran0::getNum(void) {
   long     k;
   double ans;

   dummy ^= MASK;
   k      = (dummy)/IQ;
   dummy  = IA*(dummy - k*IQ) - IR*k;
   if(dummy < 0) dummy += IM;
   ans    = AM*(dummy);
   dummy ^= MASK;
   return ans;
}
#undef IA
#undef IM
#undef AM
#undef IQ
#undef IR
#undef MASK

// ****************************************************************
// *                            RAN1                              *
// ****************************************************************
#define IA 16807
#define IM 2147483647
#define AM (1.0/IM)
#define IQ 127773
#define IR 2836
#define NTAB 32
#define NDIV (1+(IM-1)/NTAB)
#define EPS 1.2e-7
#define RNMX (1.0-EPS)

double Ran1::getNum(void)
{
   int             j;
   long            k;
   static long     iy=0;
   static long     iv[NTAB];
   double          temp;

   if (dummy <= 0 || !iy) {
      if (-(dummy) < 1) dummy=1;
      else dummy = -(dummy);
      for(j = NTAB + 7; j >= 0; j--) {
         k     = (dummy)/IQ;
         dummy = IA*(dummy - k*IQ) - IR*k;
         if(dummy < 0) dummy += IM;
         if(j < NTAB) iv[j] = dummy;
      }
      iy = iv[0];
   }
   k     = (dummy)/IQ;
   dummy = IA*(dummy - k*IQ) - IR*k;
   if(dummy < 0) dummy += IM;
   j     = iy/NDIV;
   iy    = iv[j];
   iv[j] = dummy;
   if((temp=AM*iy) > RNMX) return RNMX;
   else return temp;
}
#undef IA
#undef IM
#undef AM
#undef IQ
#undef IR
#undef NTAB
#undef NDIV
#undef EPS
#undef RNMX
\end{lstlisting}


\newpage


% *************************************************************
% *                                                           *
% *                         SLATERDET.H                       *
% *                                                           *
% *************************************************************
\subsection{SlaterDet.h}
\begin{lstlisting}
#ifndef SlaterDet_IS_INCLUDED
#define SlaterDet_IS_INCLUDED

#include <iostream>
#include "../SlaterMatrix/SlaterMatrix.h"
#include "../Coor/Coor.h"
#include "../Domain/Domain.h"
#include "../Func/Func.h"
#include "../SingleParticleFuncs/SingleParticleFuncs.h"
#include "../Random/Random.h"
#include "../Ref/Ref.h"


// ****************************************************************
// *                         SLATERDET                            *
// ****************************************************************
template <class FuncUp, class FuncDown>
class SlaterDet {
   
 protected:
   
  SlaterMatrix_Det *smUp, *smDown;
   
  int          numParticles;
  int          numDimensions;
  int          dimUp, dimDown;
  double       *newValuesColumnUp, *newValuesColumnDown;
  int          *columnIndexOfParticle;
  
  Domain       *domain;
  CoorSpinDiff *coors;
  Ref<CoorSpinDiff> trialCoor;
  FuncUp       *funcsUp;
  FuncDown     *funcsDown;
  Ref<Random2> random;
  
  Ref<double>  ratioUp, ratioDown;
  double       ratio;
  double       dDiffRatio;
  double       *diffRatios, *_diffRatios;
  double       det;
  Ref<double>  detUp, detDown;
  double       trialDet;
  Ref<double>  trialDetUp, trialDetDown;
  
  int          *spinFlip;
  int          currentParticle;
  int          otherParticle;
  int          spin;
  int          currentColumn;
  int          otherColumn;
  int          moveAcceptance, flipAcceptance, moveFlipAcceptance;
  
#ifdef _DEBUG_
  int          moved, flipped, valueSidesCalculated;
#endif
  
 public:
  
  SlaterDet();
  ~SlaterDet();

  void      init(Domain* _domain, int alphaVar);
  void      initNewVmcRun();
  void      setToNextParticle();
  void      setCurrentParticle(int _currentParticle);
  
  void      suggestMove();
  void      suggestFlip();
  void      suggestMoveFlip();
  
  void      acceptMove();
  void      acceptFlip();
  void      acceptMoveFlip();
  
  void      rejectMove();
  void      rejectFlip();
  void      rejectMoveFlip();
  
  void      calcDiffRatios();
  void      calcDDiffRatio();
  
  void      setSpinFlip(int _sf)    {spinFlip=_sf;}
  int&      getSpinFlip()           {return spinFlip;}
  int&      getCurrentParticle()    {return currentParticle;}
  int&      getOtherParticle()      {return otherParticle;}
  double&   getDet()                {return det;}
  double&   getTrialDet()           {return trialDet;}
  double&   getRatio()              {return ratio;}
  double*   getDiffRatiosPtr()      {return diffRatios;}
  double&   getDDiffRatio()         {return dDiffRatio;}
  
  FuncUp*   getFuncsUpPtr()         {return funcsUp;}
  FuncDown* getFuncsDownPtr()       {return funcsDown;}
  int       getMoveAcceptance()     {return moveAcceptance;}
  int       getFlipAcceptance()     {return flipAcceptance;}
  int       getMoveFlipAcceptance() {return moveFlipAcceptance;}
  void      resetAcceptances();
  
  void      summary();
  void      initDiff();
  
 protected:
  
#ifdef _DEBUG_
  int       checkIfValueSidesCalculated();
#endif
};

#include "SlaterDet.cpp"

#endif
\end{lstlisting}


% *************************************************************
% *                                                           *
% *                       SLATERDET.CPP                       *
% *                                                           *
% *************************************************************
\subsection{SlaterDet.cpp}
\begin{lstlisting}
#ifndef SlaterDetCPP_IS_INCLUDED
#define SlaterDetCPP_IS_INCLUDED

#include "SlaterDet.h"

// ****************************************************************
// *                         SLATERDET                            *
// ****************************************************************
//
// ************************* SlaterDet ****************************
template <class FuncUp, class FuncDown>
SlaterDet<FuncUp, FuncDown>::SlaterDet() {}


// ************************* ~SlaterDet ***************************
template <class FuncUp, class FuncDown>
SlaterDet<FuncUp, FuncDown>::~SlaterDet() 
{
  delete[] columnIndexOfParticle;
  delete[] newValuesColumnUp;
  delete[] newValuesColumnDown;
  delete[] diffRatios;
  delete[] funcsUp;
  delete[] funcsDown;
  delete[] smUp;
  delete[] smDown;
}


// **************************** init ******************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::init(Domain* _domain, int alphaVar) {
 
  domain          = _domain; 
  numParticles    = domain->getNumParticles();
  numDimensions   = domain->getNumDimensions();
  coors           = domain->getCoors();
  trialCoor       = domain->getTrialCoor();
  spinFlip        = domain->getSpinFlip();
 
  //Calculate the number of particles with spin up and down
  //and generate initial particle index to column index transform array
  columnIndexOfParticle = new int[numParticles];
  dimUp   = 0;
  dimDown = 0;
  for (int i = 0; i < numParticles; i++)
    if (coors[i].spin() > 0)
      columnIndexOfParticle[i] = dimUp++;
    else  // if (coors[i].spin() == -1)
      columnIndexOfParticle[i] = dimDown++;

  //Allocate newValueColumn arrays
  newValuesColumnUp   = new double[dimUp];
  newValuesColumnDown = new double[dimDown];
  
  //Allocate array for first derivative ratios
  diffRatios = new double[numParticles*numDimensions + 1];
  
  //Generate function objects
  funcsUp   = new FuncUp[dimUp];
  funcsDown = new FuncDown[dimDown];
  for (int i = 0; i < dimUp; i++) {
    funcsUp[i].init(trialCoor(), dimUp, domain, alphaVar);
    funcsUp[i].attachResult(newValuesColumnUp);
    funcsUp[i].attachDdiffResult(newValuesColumnUp);
  }
  for (int i = 0; i < dimDown; i++) {
    funcsDown[i].init(trialCoor(), dimDown, domain, alphaVar);
    funcsDown[i].attachResult(newValuesColumnDown);
    funcsDown[i].attachDdiffResult(newValuesColumnDown);
  }
  
  //Generate SlaterMatrix objects
  smUp   = new SlaterMatrix_Det[1];
  smDown = new SlaterMatrix_Det[1];
  smUp->redim(dimUp);
  smUp->setPtrToNewColumn(newValuesColumnUp);
  smDown->redim(dimDown);
  smDown->setPtrToNewColumn(newValuesColumnDown);
  ratioUp      = smUp->getRatio();
  ratioDown    = smDown->getRatio();
  detUp        = smUp->getDet();
  detDown      = smDown->getDet();
  trialDetUp   = smUp->getTrialDet();
  trialDetDown = smDown->getTrialDet();
  
  //Initialize SlaterMatrix objects
  for (int i = 0; i < dimUp; i++) {
    funcsUp[i].calcValueCenter(coors[i]);
    funcsUp[i].valuePt();
    smUp->calcRatio();
    smUp->importNewColumn();
    smUp->setToNextColumn();
  }
  for (int i = 0; i < dimDown; i++) {
    funcsDown[i].calcValueCenter(coors[i+dimUp]);
    funcsDown[i].valuePt();
    smDown->calcRatio();
    smDown->importNewColumn();
    smDown->setToNextColumn();
  }
  
#ifdef _DEBUG_
  moved = flipped = valueSidesCalculated = 0;
#endif
  
  setCurrentParticle(0);
  resetAcceptances();
  initDiff();
}


// *********************** initNewVmcRun **************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::initNewVmcRun() {

  //Calculate the number of particles with spin up and down
  //and generate initial particle index to column index transform array
  dimUp   = 0;
  dimDown = 0;
  for (int i = 0; i < numParticles; i++)
    if (coors[i].spin() > 0)
      columnIndexOfParticle[i] = dimUp++;
    else   // if (coors[i].spin() == -1)
      columnIndexOfParticle[i] = dimDown++;
  
  //Initialize SlaterMatrix objects
  smUp->init();
  for (int i = 0; i < dimUp; i++) {
    funcsUp[i].calcValueCenter(coors[i]);
    funcsUp[i].valuePt();
    smUp->calcRatio();
    smUp->importNewColumn();
    smUp->setToNextColumn();
  }

  smDown->init();
  for (int i = 0; i < dimDown; i++) {
    funcsDown[i].calcValueCenter(coors[i+dimUp]);
    funcsDown[i].valuePt();
    smDown->calcRatio();
    smDown->importNewColumn();
    smDown->setToNextColumn();
  }
  setCurrentParticle(0);
  resetAcceptances();
  initDiff();
}
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::suggestMove() {
#ifdef _DEBUG_
  if (moved == 1 || flipped == 1) {
    cerr << "\nCannot move. Change already suggested.\nAccept or reject first.\n";
    return;
  }
#endif
  
  currentColumn = columnIndexOfParticle[currentParticle];
  
  if (spin > 0) {
    funcsUp[currentColumn].calcValueCenter();
    funcsUp[currentColumn].valuePt();
    smUp->setCurrentColumn(currentColumn);
    smUp->calcRatio();
    ratio    = ratioUp();
    trialDet = trialDetUp();
  }
  else {
    funcsDown[currentColumn].calcValueCenter();
    funcsDown[currentColumn].valuePt();
    smDown->setCurrentColumn(currentColumn);
    smDown->calcRatio();
    ratio    = ratioDown();
    trialDet = trialDetDown();
  }
  
#ifdef _DEBUG_
  moved = 1;
  valueSidesCalculated = 0;
#endif
}


// ************************ suggestFlip ***************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::suggestFlip() {
#ifdef _DEBUG_
  if (moved == 1 || flipped == 1) {
    cerr << "\nCannot flip. Change already suggested.\nAccept or reject first.\n";
    return;
  }
#endif
  
  //Find a particle with a spin opposite of the current particle
  while ( coors[otherParticle = (int)(random().getNum() * numParticles)].spin() == spin );
  
  currentColumn = columnIndexOfParticle[currentParticle];
  otherColumn   = columnIndexOfParticle[otherParticle];
  
  if (spin > 0) {
    funcsUp[currentColumn].calcValueCenter(coors[otherParticle]);
    funcsDown[otherColumn].calcValueCenter(coors[currentParticle]);
    funcsUp[currentColumn].valuePt();
    funcsDown[otherColumn].valuePt();
    smUp->setCurrentColumn(currentColumn);
    smDown->setCurrentColumn(otherColumn);
  }
  else {
    funcsDown[currentColumn].calcValueCenter(coors[otherParticle]);
    funcsUp[otherColumn].calcValueCenter(coors[currentParticle]);
    funcsDown[currentColumn].valuePt();
    funcsUp[otherColumn].valuePt();
    smDown->setCurrentColumn(currentColumn);
    smUp->setCurrentColumn(otherColumn);
  }
  
  smUp->calcRatio();
  smDown->calcRatio();
  
  ratio    = ratioUp()    * ratioDown();
  trialDet = trialDetUp() * trialDetDown();
  
#ifdef _DEBUG_
  flipped = 1;
  valueSidesCalculated = 0;
#endif
}


// ********************** suggestMoveFlip *************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::suggestMoveFlip() {
#ifdef _DEBUG_
  if (moved == 1 || flipped == 1) {
    cerr << "\nCannot move-flip. Change already suggested.\nAccept or reject first.\n";
    return;
  }
#endif
  
  //Find a particle with a spin opposite of the current particle
  //while ( coors[otherParticle = (int)(random().getNum() * numParticles)].spin() == spin );

  // Chose otherParticle randomly, and if the spins differ flip spin
  // otherParticle = (int)(random().getNum() * numParticles);
  // spinFlip = (coors[otherParticle].spin() == spin);
  if (!*spinFlip) suggestMove();
  else {
    otherParticle = domain->getOtherParticle();
    currentColumn = columnIndexOfParticle[currentParticle];
    otherColumn   = columnIndexOfParticle[otherParticle];
  
    if (spin > 0) {
      funcsUp[currentColumn].calcValueCenter(coors[otherParticle]);
      funcsDown[otherColumn].calcValueCenter();
      funcsUp[currentColumn].valuePt();
      funcsDown[otherColumn].valuePt();
      smUp->setCurrentColumn(currentColumn);
      smDown->setCurrentColumn(otherColumn);
    }
    else {
      funcsDown[currentColumn].calcValueCenter(coors[otherParticle]);
      funcsUp[otherColumn].calcValueCenter();
      funcsDown[currentColumn].valuePt();
      funcsUp[otherColumn].valuePt();
      smDown->setCurrentColumn(currentColumn);
      smUp->setCurrentColumn(otherColumn);
    }
  
    smUp->calcRatio();
    smDown->calcRatio();
  
    ratio    = ratioUp()    * ratioDown();
    trialDet = trialDetUp() * trialDetDown();
  
#ifdef _DEBUG_
  moved = flipped = 1;
  valueSidesCalculated = 0;
#endif
  }

}


// ************************ acceptMove ****************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::acceptMove() {
#ifdef _DEBUG_
  if (flipped == 1 || moved == 0) {
    cerr << "\nCannot accept move. A flip or a move-flip (or none) was suggested.\n";
    return;
  }
#endif

  if (spin > 0) {
    smUp->importNewColumn();
    det = detUp();
    //Calculate and store differentiated values of single orbital
    //functions. These values will be needed to calculate the first and
    //second derivatives later on.
    funcsUp[currentColumn].calcValueSides();
  }
  else {
    smDown->importNewColumn();
    det = detDown();
    //Calculate and store differentiated values of single orbital
    //functions. These values will be needed to calculate the first
    //and second derivatives later on.
    funcsDown[currentColumn].calcValueSides();
  }
  
  moveAcceptance++;
  
#ifdef _DEBUG_
  moved = valueSidesCalculated = 0;
#endif
}


// ************************ acceptFlip ****************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::acceptFlip() {
#ifdef _DEBUG_
  if (moved == 1 || flipped == 0) {
    cerr << "\nCannot accept flip. A move or a move-flip (or none) was suggested.\n";
    return;
  }
#endif

  if (spin > 0) {
    funcsUp[currentColumn].calcValueSides(coors[otherParticle]);
    funcsDown[otherColumn].calcValueSides(coors[currentParticle]);
  }
  else {
    funcsDown[currentColumn].calcValueSides(coors[otherParticle]);
    funcsUp[otherColumn].calcValueSides(coors[currentParticle]);
  }
  
  //Let the slater matrices import their new columns
  smUp->importNewColumn();
  smDown->importNewColumn();
  det = detUp() * detDown();
  
  //Flip the spin coordinates of the particles involved
  coors[currentParticle].flipSpin();
  coors[otherParticle].flipSpin();
  
  //Interchange indices in particle to column transform array
  columnIndexOfParticle[currentParticle] = otherColumn;
  columnIndexOfParticle[otherParticle]   = currentColumn;
  
  flipAcceptance++;
  
#ifdef _DEBUG_
  flipped = valueSidesCalculated = 0;
#endif
}


// ********************** acceptMoveFlip **************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::acceptMoveFlip() {
  if (!*spinFlip) acceptMove();
  else {
#ifdef _DEBUG_
    if (moved == 0 || flipped == 0) {
      cerr << "\nCannot accept move-flip. A move or a flip (or none) was suggested.\n";
      return;
    }
#endif
    if (spin > 0) {
      funcsUp[currentColumn].calcValueSides(coors[otherParticle]);
      funcsDown[otherColumn].calcValueSides();
    }
    else {
      funcsDown[currentColumn].calcValueSides(coors[otherParticle]);
      funcsUp[otherColumn].calcValueSides();
    }
  
    //Let the slater matrices import their new columns
    smUp->importNewColumn();
    smDown->importNewColumn();
    det = detUp() * detDown();
    
    //Flip the spin coordinates of the particles involved
    coors[currentParticle].flipSpin();
    coors[otherParticle].flipSpin();
    
    //Interchange indices in particle to column transform array
    columnIndexOfParticle[currentParticle] = otherColumn;
    columnIndexOfParticle[otherParticle]   = currentColumn;
  }
  
  moveFlipAcceptance++;
  
#ifdef _DEBUG_
  moved = flipped = valueSidesCalculated = 0;
#endif

}


// ************************ rejectMove ****************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::rejectMove() {
#ifdef _DEBUG_
  if (flipped == 1 || moved == 0) {
    cerr << "\nCannot reject move. A flip or a move-flip (or none) was suggested.\n";
    return;
  }
  moved = 0;
#endif
  
  if (spin > 0) {
    //Recalculate and store values of single orbital functions. These
    //values will be needed to calculate the first and second
    //derivatives later on.
    funcsUp[currentColumn].calcValueCenter(coors[currentParticle]);
  }
  else {
    //Calculate and store values of single orbital functions. These
    //values will be needed to calculate the first and second
    //derivatives later on.
    funcsDown[currentColumn].calcValueCenter(coors[currentParticle]);
  }
  
}


// ************************ rejectFlip ****************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::rejectFlip() {
#ifdef _DEBUG_
  if (moved == 1 || flipped == 0) {
    cerr << "\nCannot reject flip. A move or a move-flip (or none) was suggested.\n";
    return;
  }
  flipped = 0;
#endif
  
  if (spin > 0) {
    funcsUp[currentColumn].calcValueCenter(coors[currentParticle]);
    funcsDown[otherColumn].calcValueCenter(coors[otherParticle]);
  }
  else {
    funcsDown[currentColumn].calcValueCenter(coors[currentParticle]);
    funcsUp[otherColumn].calcValueCenter(coors[otherParticle]);
  }
  
}


// ********************** rejectMoveFlip **************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::rejectMoveFlip() {

  if (!*spinFlip) rejectMove();
  else {
#ifdef _DEBUG_
    if (moved == 0 || flipped == 0) {
      cerr << "\nCannot reject move-flip. A move or a flip (or none) was suggested.\n";
      return;
    }
    moved = flipped = 0;
#endif
  
    if (spin > 0) {
      funcsUp[currentColumn].calcValueCenter(coors[currentParticle]);
      funcsDown[otherColumn].calcValueCenter(coors[otherParticle]);
    }
    else {
      funcsDown[currentColumn].calcValueCenter(coors[currentParticle]);
      funcsUp[otherColumn].calcValueCenter(coors[otherParticle]);
    }
  }
}


// ********************* setToNextParticle ************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::setToNextParticle() {
#ifdef _DEBUG_
  if (moved == 1 || flipped == 1) {
    cerr << "\nA move, flip or move-flip was suggested.\nAccept or reject before setting to next particle.\n";
    return;
  }
#endif
  
  if (++currentParticle == numParticles)
    currentParticle = 0;
  
  spin = coors[currentParticle].spin();
}


// ********************* setCurrentParticle ***********************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::setCurrentParticle(int _currentParticle) {
#ifdef _DEBUG_
  if (moved == 1 || flipped == 1) {
    cerr << "\nA move, flip or move-flip was suggested.\nAccept or reject before setting particle index.\n";
    return;
  }
#endif
  
  currentParticle = _currentParticle;
  spin = coors[currentParticle].spin();
}


// ************************** initDiff ****************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::initDiff() {
  for (int i = 0; i < numParticles; i++)
    if (coors[i].spin() > 0) {
      funcsUp[columnIndexOfParticle[i]].calcValueCenter(coors[i]);
      funcsUp[columnIndexOfParticle[i]].calcValueSides(coors[i]);
    }
    else {
      funcsDown[columnIndexOfParticle[i]].calcValueCenter(coors[i]);
      funcsDown[columnIndexOfParticle[i]].calcValueSides(coors[i]);
   }

#ifdef _DEBUG_
  valueSidesCalculated = 1;
#endif
}


// *********************** calcDiffRatios *************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::calcDiffRatios() {
#ifdef _DEBUG_
  if (checkIfValueSidesCalculated() == 0) {
    cerr << "\nCannot calculate diffRatios.\n";
    exit(1);
  }
#endif
  
  _diffRatios = diffRatios;
  for (int i = 0; i < numParticles; i++)
    if (coors[i].spin() > 0) {
      smUp->setCurrentColumn(columnIndexOfParticle[i]);
      for (int j = 0; j < numDimensions; j++) {
        funcsUp[columnIndexOfParticle[i]].diff(j);
        smUp->calcRatio();
        *_diffRatios++ = ratioUp();
      }
    }
    else {
      smDown->setCurrentColumn(columnIndexOfParticle[i]);
      for (int j = 0; j < numDimensions; j++) {
        funcsDown[columnIndexOfParticle[i]].diff(j);
        smDown->calcRatio();
        (*_diffRatios++) = ratioDown();
      }
    }
}


// *********************** calcDDiffRatio *************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::calcDDiffRatio() {
#ifdef _DEBUG_
  if (checkIfValueSidesCalculated() == 0) {
    cerr << "\nCannot calculate dDiffRatio.\n";
    exit(1);
  }
#endif

  dDiffRatio = 0;
  for (int i = 0; i < dimUp; i++) {
    smUp->setCurrentColumn(i);
    funcsUp[i].ddiff();
    smUp->calcRatio();
    dDiffRatio += ratioUp();
  }
  for (int i = 0; i < dimDown; i++) {
    smDown->setCurrentColumn(i);
    funcsDown[i].ddiff();
    smDown->calcRatio();
    dDiffRatio += ratioDown();
  }
}


// ************************** summary *****************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::summary() {
  cerr << "\n\n--------------------------------------------------";
  cerr << "\n SUMMARY OF SlaterDet INSTANCE\n\n";
  
  smUp->summary();
  smDown->summary();
}


// ********************** resetAcceptances ************************
template <class FuncUp, class FuncDown>
void SlaterDet<FuncUp, FuncDown>::resetAcceptances() {
  moveAcceptance = flipAcceptance = moveFlipAcceptance = 0;
}


#ifdef _DEBUG_
template <class FuncUp, class FuncDown>
int SlaterDet<FuncUp, FuncDown>::checkIfValueSidesCalculated() {
  /*
  if (valueSidesCalculated == 0) {
    cerr << "\nvalueSides not yet calculated.";
    return 0;
  }
  */
  return 1;
}
#endif

#endif
\end{lstlisting}


\newpage


% *************************************************************
% *                                                           *
% *                      SLATERMATRIX.H                       *
% *                                                           *
% *************************************************************
\subsection{SlaterMatrix.h}
\begin{lstlisting}
#ifndef SlaterMatrix_IS_INCLUDED
#define SlaterMatrix_IS_INCLUDED

#include <string>
#include <iostream>
#include <cstdio>
#include <cstdlib>

using namespace std;

// ****************************************************************
// *                        SLATERMATRIX                          *
// ****************************************************************
class SlaterMatrix {

 protected:
  //Primary variables
  double* inverseMatrix;
  double* inverseMatrixCurrentRow;
  double* newColumn;
  double  ratio;
  int     dim;
  int     currentColumn;
  int     isAllocated;
#ifdef _DEBUG_
  int     ratioIsCalculated;
#endif

  //Iterating and secondary variables
  double* _inverseMatrix;
  double* _inverseMatrixCurrentRow;
  double* _newColumn;
  double  result;
  double  invRatio;

 public:
  SlaterMatrix();
  SlaterMatrix(int __dim);
  virtual        ~SlaterMatrix();
  void            init();
  void            redim(int __dim);
  void    setPtrToNewColumn(double* __newColumn);
  virtual void    setCurrentColumn(int __currentColumn);
  virtual void    setToNextColumn();
  virtual void    resetPtr();
  virtual void    calcRatio();
  virtual void    importNewColumn();
  void            importNewMatrixColumnwise(double* __matrix);
  virtual void    setMatrixToUnity();

  virtual void    summary();

  double&         getRatio()        {return ratio;}
  int             getDim()          {return dim;}
  double*         getInvMatrixPtr() {return inverseMatrix;}

 protected:
  virtual int     allocateMemory(int __dim);
  virtual void    deleteMemory();
#ifdef _DEBUG_
  int     checkAllocation();
  int     checkIfRatioCalculated();
#endif

};


// ****************************************************************
// *                      SLATERMATRIX_DET                        *
// ****************************************************************
class SlaterMatrix_Det : public SlaterMatrix {

 protected:
  double trialDeterminant;
  double determinant;

 public:
  SlaterMatrix_Det();
  SlaterMatrix_Det(int __dim);
  virtual         ~SlaterMatrix_Det();
  inline void      importNewColumn();
  void             setMatrixToUnity();
  inline void      calcRatio();

  virtual void     summary();

  double&          getDet()         {return determinant;}
  double&          getTrialDet()    {return trialDeterminant;}
};

#endif
\end{lstlisting}


% *************************************************************
% *                                                           *
% *                     SLATERMATRIX.CPP                      *
% *                                                           *
% *************************************************************
\subsection{SlaterMatrix.cc}
\begin{lstlisting}
#define TRUE 1
#define FALSE 0
#define NULL 0

#include "SlaterMatrix.h"

// ****************************************************************
// *                        SLATERMATRIX                          *
// ****************************************************************
//
// ************************ SlaterMatrix **************************
SlaterMatrix::SlaterMatrix() {
#ifdef _DEBUG_
  ratioIsCalculated = FALSE;
#endif

  isAllocated       = FALSE;
}

// ************************ SlaterMatrix **************************
SlaterMatrix::SlaterMatrix(int __dim) {
  isAllocated       = FALSE;
#ifdef _DEBUG_
  ratioIsCalculated = FALSE;
#endif

  redim(__dim);
}


// ************************ ~SlaterMatrix *************************
SlaterMatrix::~SlaterMatrix() {
  deleteMemory();
}


// **************************** init ******************************
void SlaterMatrix::init() {
  setMatrixToUnity();
  setCurrentColumn(0);
}


// **************************** redim *****************************
void SlaterMatrix::redim(int __dim) {
  deleteMemory();
  allocateMemory(__dim);
  init();
}


// ********************** setPtrToNewColumn ***********************
void SlaterMatrix::setPtrToNewColumn(double* __newColumn) {
#ifdef _DEBUG_
  if (newColumn != __newColumn)
    ratioIsCalculated = FALSE;
#endif

  newColumn = __newColumn;
}


// ********************** setCurrentColumn ************************
void SlaterMatrix::setCurrentColumn(int __currentColumn) {
#ifdef _DEBUG_
  if (checkAllocation() == 1) exit(1);
  if (currentColumn != __currentColumn)
    ratioIsCalculated = FALSE;
#endif
  
  currentColumn = __currentColumn;
  inverseMatrixCurrentRow = (inverseMatrix + dim*currentColumn);
}


// *********************** setToNextColumn ************************
void SlaterMatrix::setToNextColumn() {
#ifdef _DEBUG_
  if (checkAllocation() == 1) exit(1);
#endif
  
  if (++currentColumn == dim) {
    currentColumn = 0;
    resetPtr();
  }
  else
    inverseMatrixCurrentRow += dim;
  
#ifdef _DEBUG_
  ratioIsCalculated = FALSE;
#endif
}


// *************************** resetPtr ***************************
void SlaterMatrix::resetPtr() {
  inverseMatrixCurrentRow = inverseMatrix;
}


// ************************** calcRatio ***************************
void SlaterMatrix::calcRatio() {
#ifdef _DEBUG_
  if (checkAllocation() == 1) {
    cerr << "\nCannot calculate determinant ratio.";
    exit(1);
  }
#endif
  
  _newColumn               = newColumn;
  _inverseMatrixCurrentRow = inverseMatrixCurrentRow;
  
  ratio = 0;
  for (int i = 0; i < dim; i++)
    ratio += ( (*_newColumn++) * (*_inverseMatrixCurrentRow++));
  
#ifdef _DEBUG_
  if (ratio == 0)
    cerr << "\nRatio = 0.\n If new column is imported, slater matrix will not beinvertible.\n";
  ratioIsCalculated = TRUE;
#endif
}


// *********************** importNewColumn ************************
void SlaterMatrix::importNewColumn() {
#ifdef _DEBUG_
  if (checkAllocation() == 1) return;
  if (checkIfRatioCalculated() == 1) {
    cerr << "\nCannot update inverse matrix. Determinant ratio not calculated.";
    exit(1);
  }
#endif
  
  _inverseMatrix           = inverseMatrix;
  _inverseMatrixCurrentRow = inverseMatrixCurrentRow + dim;
  invRatio = 1/ratio;
  
  for (int i = 0; i < dim; i++)
    if (i != currentColumn) {
      result     = 0;
      _newColumn = newColumn;
      
      for (int j = 0; j < dim; j++)
        result += ((*_newColumn++) * (*_inverseMatrix++));
      
      result *= invRatio;
      
      _inverseMatrix           -= dim;
      _inverseMatrixCurrentRow -= dim;
      for (int j = 0; j < dim; j++)
        (*_inverseMatrix++) -= ((*_inverseMatrixCurrentRow++) * result);
    }
    else
      _inverseMatrix += dim;
  
  _inverseMatrixCurrentRow -= dim;
  for (int i = 0; i < dim; i++)
    (*_inverseMatrixCurrentRow++) *= invRatio;
  
#ifdef _DEBUG_
  ratioIsCalculated = FALSE;
#endif
  
}


// ****************** importNewMatrixColumnwise *******************
void SlaterMatrix::importNewMatrixColumnwise(double* __matrix) {
#ifdef _DEBUG_
  if (checkAllocation() == 1) {
    cerr << "\nCannot import new matrix.";
    exit(1);
  }
#endif
  
  double* __newColumn     = newColumn;
  int     __currentColumn = currentColumn;
  
  setCurrentColumn(0);
  for (int i = 0; i < dim; i++) {
    setPtrToNewColumn(__matrix);
    calcRatio();
    importNewColumn();
    setToNextColumn();
    __matrix += dim;
  }
  
  setPtrToNewColumn(__newColumn);
  setCurrentColumn(__currentColumn);
  
#ifdef _DEBUG_
  ratioIsCalculated = FALSE;
#endif
}


// ********************** setMatrixToUnity ************************
void SlaterMatrix::setMatrixToUnity() {
#ifdef _DEBUG_
  if (checkAllocation() == 1) {
    cerr << "\nCannot set matrix to unity.";
    exit(1);
  }
#endif

  _inverseMatrix = inverseMatrix;
  
  for (int i = 0; i < dim; i++)
    for (int j = 0; j < dim; j++)
      *_inverseMatrix++ = ( j==i );
  
#ifdef _DEBUG_
  ratioIsCalculated = FALSE;
#endif
}


// *************************** summary ****************************
void SlaterMatrix::summary() {
  string result;
  char   buffer[50];
  
#ifdef _DEBUG_
  if (checkAllocation() == 1)
    exit(1);
#endif
  
  cerr << "\n--------------------------------------------------";
  cerr << "\nDimension: " << dim << "\n";
  cerr << "\nInverse slater matrix:\n\n";
  
  for (int i = 0; i < dim; i++) {
    for (int j = 0; j < dim; j++) {
      snprintf(buffer, 50, "%10.5f", inverseMatrix[i*dim + j]);
      result += buffer;
      if (j != (dim-1))
        result += ", ";
    }
    result += "\n";
  }
  
  cerr << result;
  
}


// *********************** allocateMemory *************************
int SlaterMatrix::allocateMemory(int __dim) {
  if (isAllocated) return 1;
  
  inverseMatrix = new double[__dim*__dim+1];
  dim = __dim;
  
  isAllocated = TRUE;
  
  return 0;
}


// ************************ deleteMemory **************************
void SlaterMatrix::deleteMemory() {
  if (isAllocated)
    delete[] inverseMatrix;
  isAllocated = FALSE;
}


#ifdef _DEBUG_


// *********************** checkAllocation ************************
int SlaterMatrix::checkAllocation() {
  if (!isAllocated) {
    cerr << "\nNo memory allocated for inverse slater matrix.";
    return 1;
  }
  
  return 0;
}


// ******************** checkIfRatioCalculated ********************
int SlaterMatrix::checkIfRatioCalculated() {
  if (!ratioIsCalculated) {
    cerr << "\nDeterminant ratio not yet calculated.";
    return 1;
  }
  
  return 0;
}

#endif


// ****************************************************************
// *                      SLATERMATRIX_DET                        *
// ****************************************************************
//
// ********************** SlaterMatrix_Det ************************
SlaterMatrix_Det::SlaterMatrix_Det() : SlaterMatrix() {
}


// ********************** SlaterMatrix_Det ************************
SlaterMatrix_Det::SlaterMatrix_Det(int __dim) : SlaterMatrix(__dim){
}


// ********************** ~SlaterMatrix_Det ***********************
SlaterMatrix_Det::~SlaterMatrix_Det() {
  deleteMemory();
}


// ************************** calcRatio ***************************
void SlaterMatrix_Det::calcRatio() {
  SlaterMatrix::calcRatio();
  trialDeterminant = ratio*determinant;
}


// *********************** importNewColumn ************************
void SlaterMatrix_Det::importNewColumn() {
  SlaterMatrix::importNewColumn();
  determinant = trialDeterminant;
}


// ********************** setMatrixToUnity ************************
void SlaterMatrix_Det::setMatrixToUnity() {
  SlaterMatrix::setMatrixToUnity();
  determinant = 1.;
}


// *************************** summary ****************************
void SlaterMatrix_Det::summary() {
  SlaterMatrix::summary();
  cerr << "\nDeterminant: " << determinant << endl;
}
\end{lstlisting}



\newpage




% *************************************************************
% *                                                           *
% *                          FUNC.H                           *
% *                                                           *
% *************************************************************
\subsection{Func.h}
\begin{lstlisting}
#ifndef Func_IS_INCLUDED
#define Func_IS_INCLUDED

#include <string>
#include <cstdio>
#include <cstdlib>
#include <iostream>
#include "../Coor/Coor.h"
#include "../Functor/Functor.h"
#include "../Ref/Ref.h"
#include "../Domain/Domain.h"
#include "../SingleParticleFuncs/SingleParticleFuncs.h"

using namespace std;


// ****************************************************************
// *                            FUNC                              *
// ****************************************************************
template <class Param>
class Func {

 protected:
  Ref<Param>     coordinate;
  SingleParticleFunc<Param>** function;
  double         h, h_half, h_double, h_inv, h_inv2, h_invdouble;
  double*        values;
  double*        result;
  double*        diffResult;
  double*        ddiffResult;
  int            numDimensions;

 public:
  Func(Param& _coordinate);
  Func();
  virtual ~Func();
  virtual void   init();
  virtual void   init(Param& _coordinate);
  virtual void   attachNumDimensions(int _numDimensions) 
    { numDimensions = _numDimensions; }
  virtual void   setCoordinate(Param& _coordinate);
  virtual void   calcValueCenter();
  virtual void   calcValueCenter(Param& _coordinate);
  virtual void   calcValueSides();
  virtual void   calcValueSides(Param& _coordinate);
  virtual double valuePt();
  virtual double diff();
  virtual double ddiff();
  virtual void   attachResult(double* __result);
  virtual void   attachDiffResult(double* __diffResult);
  virtual void   attachDdiffResult(double* __ddiffResult);
  virtual Param& getCoordinate() {return coordinate();}
  virtual void   summary();

 protected:
  virtual void   calcH();

};


// ****************************************************************
// *                           FUNCSET                            *
// ****************************************************************
template <class Param>
class FuncSet : public Func<Param> {

 protected:
  int         len;
  double*     valuesM;
  double*     valuesP;

 public:
  FuncSet(Param& _coordinate, int _len);
  FuncSet();
  virtual ~FuncSet();
  virtual void   init();
  virtual void   init(Param& _coordinate, int _len);
  virtual void   calcValueCenter();
  virtual void   calcValueCenter(Param& _coordinate);
  virtual void   calcValueSides();
  virtual void   calcValueSides(Param& _coordinate);
  virtual double valuePt();
  virtual double diff();
  virtual double ddiff();
  virtual void   summary();

};


// ****************************************************************
// *                       FUNCSETMULTIVAR                        *
// ****************************************************************
template <class Param>
class FuncSetMultivar : public FuncSet<Param> {
 protected:
  int      numVar;
  int      len_double;
  double*  _diffResult;

 public:
  FuncSetMultivar(Param& _coordinate, int _len);
  FuncSetMultivar();
  virtual ~FuncSetMultivar();
  virtual void   init();
  virtual void   init(Param& _coordinate, int _len);
  virtual void   calcValueSides();
  virtual void   calcValueSides(Param& _coordinate);
  virtual double diff();
  virtual double diff(int v);
  virtual double ddiff();
  virtual void   attachDiffResult(double* __diffResult);
  virtual void   summary();
};

#include "Func.cpp"

#endif
\end{lstlisting}


% *************************************************************
% *                                                           *
% *                          FUNC.CPP                         *
% *                                                           *
% *************************************************************
\subsection{Func.cpp}
\begin{lstlisting}
#ifndef FuncCPP_IS_INCLUDED
#define FuncCPP_IS_INCLUDED

#include "Func.h"


// ****************************************************************
// *                            FUNC                              *
// ****************************************************************
//
// **************************** Func ******************************
template <class Param>
Func<Param>::Func(Param& _coordinate) {
  setCoordinate(_coordinate);
  calcH();
  numDimensions = 1;
}

template <class Param>
Func<Param>::Func() {
  calcH();
  numDimensions = 1;
}


// *************************** ~Func ******************************
template <class Param>
Func<Param>::~Func() {
  delete[] function[0];
  delete[] values;
}


// **************************** init ******************************
template <class Param>
void Func<Param>::init(Param& _coordinate) {
  setCoordinate(_coordinate);
  init();
}

template <class Param>
void Func<Param>::init() {
  function = new SingleParticleFunc<Param>*;
  values   = new double[3];
}


// *********************** setCoordinate **************************
template <class Param>
void Func<Param>::setCoordinate(Param& _coordinate) {
  coordinate = _coordinate;
}


// *************************** calcH ******************************
template <class Param>
void Func<Param>::calcH() {
  h           = 1e-4;
  h_half      = 0.5*h;
  h_double    = 2.0*h;
  h_inv       = 1./h;
  h_inv2      = 1./(h*h);
  h_invdouble = 1./(2.*h);
}


// ********************** calcValueCenter *************************
template <class Param>
void Func<Param>::calcValueCenter() {
  (*values) = (**function)(coordinate());
}

template <class Param>
void Func<Param>::calcValueCenter(Param& _coordinate) {
  (*values) = (**function)(_coordinate);
}


// ********************** calcValueSides **************************
template <class Param>
void Func<Param>::calcValueSides() {
  values[1] = (**function)(coordinate(), 0);
  values[2] = (**function)(coordinate(), 1);
}

template <class Param>
void Func<Param>::calcValueSides(Param& _coordinate) {
  values[1] = (**function)(_coordinate, 0);
  values[2] = (**function)(_coordinate, 1);
}


// ************************** valuePt *****************************
template <class Param>
double Func<Param>::valuePt() {
  return (*result = values[0]);
}


// **************************** diff ******************************
template <class Param>
double Func<Param>::diff() {
  *diffResult = (values[1] - values[2])*h_invdouble;
  return *diffResult;
}


// *************************** ddiff ******************************
template <class Param>
double Func<Param>::ddiff() {
  *ddiffResult = (values[1] + values[2] - 2*values[0])*h_inv2;
  return *ddiffResult;
}


// *********************** attachResult ***************************
template <class Param>
void Func<Param>::attachResult(double* __result) {
  result = __result;
}


// ********************* attachDiffResult *************************
template <class Param>
void Func<Param>::attachDiffResult(double* __diffResult) {
  diffResult = __diffResult;
}


// ********************* attachDdiffResult ************************
template <class Param>
void Func<Param>::attachDdiffResult(double* __ddiffResult) {
  ddiffResult = __ddiffResult;
}


// ************************** summary *****************************
template <class Param>
void Func<Param>::summary() {
  cerr << "\n\n--------------------------------------------------\n";
  cerr << "Values:\n";
  cerr << " Center: " << values[0] << endl;
  cerr << " Minus:  " << values[1] << endl;
  cerr << " Plus:   " << values[2] << endl;
  cerr << "result:      "  << *result << endl;
  cerr << "diffResult:  "  << *diffResult << endl;
  cerr << "ddiffResult: "  << *ddiffResult << endl;  
}




// ****************************************************************
// *                          FUNCSET                             *
// ****************************************************************
//
// ************************** FuncSet *****************************
template <class Param>
FuncSet<Param>::FuncSet(Param& _coordinate, int _len) : 
  Func<Param>(_coordinate), len(_len) {}

template <class Param>
FuncSet<Param>::FuncSet() : Func<Param>() {}


// ************************** ~FuncSet ****************************
template <class Param>
FuncSet<Param>::~FuncSet() {
  for (int i=0; i<len; i++)
    delete[] function[i];
  delete[] values;
}


// **************************** init ******************************
template <class Param>
void FuncSet<Param>::init(Param& _coordinate, int _len) {
  len = _len;
  Func<Param>::init(_coordinate);
}

template <class Param>
void FuncSet<Param>::init() {
  values   = new double[3*len];
  valuesP  = values + len;
  valuesM  = values + len*2;
  function = new SingleParticleFunc<Param>*[len];
}


// ********************** calcValueCenter *************************
template <class Param>
void FuncSet<Param>::calcValueCenter() {
  for (int i = 0; i < len; i++)
    values[i] = function[i][0](coordinate());
}

template <class Param>
void FuncSet<Param>::calcValueCenter(Param& _coordinate) {
  for (int i = 0; i < len; i++)
    values[i] = function[i][0](_coordinate);
}


// ********************** calcValueSides **************************
template <class Param>
void FuncSet<Param>::calcValueSides() {

  for (int i = 0; i < len; i++) {
    valuesP[i] = function[i][0](coordinate(), 0);
    valuesM[i] = function[i][0](coordinate(), numDimensions );
  }
}

template <class Param>
void FuncSet<Param>::calcValueSides(Param& _coordinate) {

  for (int i = 0; i < len; i++) {
    valuesP[i] = function[i][0](_coordinate, 0);
    valuesM[i] = function[i][0](_coordinate, numDimensions );
  }
}


// ************************** valuePt *****************************
template <class Param>
double FuncSet<Param>::valuePt() {
  for (int i = 0; i < len; i++)
    result[i] = values[i];

  return 0;
}


// **************************** diff ******************************
template <class Param>
double FuncSet<Param>::diff() {
  for (int i = 0; i < len; i++)
    diffResult[i] = (valuesP[i]-valuesM[i])*h_invdouble;
  return 0;
}


// *************************** ddiff ******************************
template <class Param>
double FuncSet<Param>::ddiff() {
  for (int i = 0; i < len; i++)
    ddiffResult[i] = (valuesM[i]+valuesP[i]-2*values[i])*h_inv2;

  return 0;
}


// ************************** summary *****************************
template <class Param>
void FuncSet<Param>::summary() {
  string returnStr;
  char   buffer[50];

  cerr << "\n\n--------------------------------------------------\n";
  cerr << "Values:\n\n";
  for (int i = 0; i < len; i++) {
    snprintf(buffer, 50, "%5.5f  %5.5f  %5.5f\n", values[i], values[i+len], values[i+2*len]);
    returnStr += buffer;
  }
  cerr << endl;

  returnStr = "";
  cerr << "Result:\n";
  for (int i = 0; i < len; i++) {
    snprintf(buffer, 50, "%5.5f", result[i]);
    returnStr += buffer;
    returnStr += "\n";
  }
  cerr << returnStr;
}


/************************************************************/


template <class Param>
FuncSetMultivar<Param>::FuncSetMultivar(Param& _coordinate, int _len) : FuncSet<Param>(_coordinate, _len) {
  numVar     = coordinate.getLen();
  len_double = 2*_len;
}


template <class Param>
FuncSetMultivar<Param>::FuncSetMultivar() : FuncSet<Param>() {
}

template <class Param>
FuncSetMultivar<Param>::~FuncSetMultivar() {
  for (int i=0; i<len; i++)
    delete[] function[i];
  //delete[] function;
  delete[] values;
}


// **************************** init ******************************
template <class Param>
void FuncSetMultivar<Param>::init() {
  values   = new double[(1+2*numVar)*len];
  valuesP  = values + len;
  valuesM  = values + len*2;
  function = new SingleParticleFunc<Param>*[len];
}

template <class Param>
void FuncSetMultivar<Param>::init(Param& _coordinate, int _len) {
  numVar     = _coordinate.getLen();
  len_double = 2*_len;
  FuncSet<Param>::init(_coordinate, _len);
}


// ********************** calcValueSides **************************
template <class Param>
void FuncSetMultivar<Param>::calcValueSides() {
  //  for (int i = (numVar-1); i >= 0; i--) {
  for (int i = 0; i < numVar; i++) {

    int iNum = i + numVar;
    for (int j = 0; j < len; j++) {
      valuesP[j] = function[j][0](coordinate(), i);
      valuesM[j] = function[j][0](coordinate(), iNum );
    }
    valuesP += (len_double);
    valuesM += (len_double);
  }
  valuesP = values + len;
  valuesM = values + len_double;
}

template <class Param>
void FuncSetMultivar<Param>::calcValueSides(Param& _coordinate) {
  for (int i = 0; i < numVar; i++) {
    int iNum = i + numVar;
    for (int j = 0; j < len; j++) {
      valuesP[j] = function[j][0](_coordinate, i);
      valuesM[j] = function[j][0](_coordinate, iNum );
    }
    valuesP += (len_double);
    valuesM += (len_double);
  }
  valuesP = values + len;
  valuesM = values + len_double;
}


// **************************** diff ******************************
template <class Param>
double FuncSetMultivar<Param>::diff() {
  for (int v = (numVar-1); v > 0; v--) {
    FuncSet<Param>::diff();
    diffResult += len;
    valuesM    += (len_double);
    valuesP    += (len_double);
  }
  FuncSet<Param>::diff();

  diffResult = _diffResult;
  valuesP = values + len;
  valuesM = values + len_double;  


  return 0;
}

template <class Param>
double FuncSetMultivar<Param>::diff(int v) {
  //Calculate the first derivative with respect to the variable indexed
  //v of all the functions and place the result in the result array (!!!)
#ifdef _DEBUG_
  if (v >= numVar) {
    cerr << "\nCannot calculate first derivative. Variable index out of bound.";
    exit(1);
  }
#endif

  diffResult  = result;
  valuesM    += (len_double*v);
  valuesP    += (len_double*v);
  FuncSet<Param>::diff();

  diffResult = _diffResult;
  valuesP    = values + len;
  valuesM    = values + len_double;  

  return 0;
}


// *************************** ddiff ******************************
template <class Param>
double FuncSetMultivar<Param>::ddiff() {
  for (int i = 0; i < len; i++)
    ddiffResult[i] = -(2*numVar*values[i]);
  for (int v = (numVar-1); v > 0; v--) {
    for (int i = 0; i < len; i++) 
      ddiffResult[i] += (valuesM[i] + valuesP[i]);
    valuesP += (len_double);
    valuesM += (len_double);
  }
  for (int i = 0; i < len; i++) {
    ddiffResult[i] += (valuesM[i] + valuesP[i]);  
    ddiffResult[i] *= h_inv2;
  }

  valuesP = values + len;
  valuesM = values + len_double;

  return 0;
}


// ********************* attachDiffResult *************************
template <class Param>
void FuncSetMultivar<Param>::attachDiffResult(double* __diffResult) {
  FuncSet<Param>::attachDiffResult(__diffResult);
  _diffResult = __diffResult;
}


// ************************** summary *****************************
template <class Param>
void FuncSetMultivar<Param>::summary() {
  string returnStr;
  char   buffer[50];

  cerr << "\n\n--------------------------------------------------\n";
  cerr << "Values:\n\n";
  for (int i = 0; i < len; i++) {
    snprintf(buffer, 50, "%5.5f  ", values[i]);
    returnStr += buffer;
    for (int j = 0; j < numVar; j++) {
      snprintf(buffer, 50, "  %5.5f  %5.5f", valuesM[i+j*2*len], valuesP[i+j*2*len]);
      returnStr += buffer;
    }
    returnStr += "\n";
  }
  cerr << returnStr << endl;

  returnStr = "";
  cerr << "Result:\n";
  for (int i = 0; i < len; i++) {
    snprintf(buffer, 50, "%5.5f", result[i]);
    returnStr += buffer;
    returnStr += "\n";
  }

  cerr << returnStr;

}

#endif
\end{lstlisting}


\newpage






% *************************************************************
% *                                                           *
% *                       FUNCUPDOWN.H                        *
% *                                                           *
% *************************************************************
\subsection{FuncUpDown.h}
\begin{lstlisting}
#ifndef FuncUpDown_IS_INCLUDED
#define FuncUpDown_IS_INCLUDED

#include <cmath>
#include <iostream>
#include <fstream>
#include "../Coor/Coor.h"
#include "../SingleParticleFuncs/SingleParticleFuncs.h"
#include "../Domain/Domain.h"
#include "../Func/Func.h"

// ****************************************************************
// *                           FUNCUP                             *
// ****************************************************************
template <class Param>
class FuncUp : public FuncSetMultivar<Param> {
 protected:
  char* fixedParamsUp;

 public:
  FuncUp() {};
  virtual ~FuncUp() 
    {  
      for (int i=0; i<len; i++)
	delete function[i];
      delete function;
      delete[] values;
    }

  FuncUp(Param& coordinate, int __len) : 
    FuncSetMultivar<Param>(coordinate, __len) {}

  virtual void init(Param& coordinate, int __len, Domain* domain, 
		    int alphaVar) 
    { 
      fixedParamsUp   = domain->getFixedParamsUp();
      FuncSetMultivar<Param>::init(coordinate, __len);
      init(domain, alphaVar);
    }

  virtual void init() {
    FuncSetMultivar<Param>::init();
  }

  virtual void init(Domain* domain, int alphaVar) {
    int index = 0;
    ifstream ifile;
    ifile.open(fixedParamsUp);
    if (domain->getOrbitalType() == "Hydrogen") {
      if (domain->getUp1s())  {function[index]=new Hydr1s<Param>;  index++;}
      if (domain->getUp2s())  {function[index]=new Hydr2s<Param>;  index++;}
      if (domain->getUp2px()) {function[index]=new Hydr2px<Param>; index++;}
      if (domain->getUp2py()) {function[index]=new Hydr2py<Param>; index++;}
      if (domain->getUp2pz()) {function[index]=new Hydr2pz<Param>; index++;}
      if (index != len ) 
	cerr << "Error creating FuncUp!\nNot matching dimensions of number " 
	     << "particles spin up (" << len 
	     << ") and number of input functions\n";
      for (int i=0; i<len; i++) {
	function[i]->attach(domain->getNumAlpha(), 
			    domain->getAlphaParam(alphaVar));
      }
    }
    else if (domain->getOrbitalType() == "HartreeFock") {
      for (int i=0; i<len; i++) {
	function[i] = new HF<Param>;
	function[i]->readHFparams(ifile);
      }
    }
    for (int i=0; i<len; i++)
      function[i]->setNumberDimensions(domain->getNumDimensions());
    ifile.close();
  }
};


// ****************************************************************
// *                          FUNCDOWN                            *
// ****************************************************************
template <class Param>
class FuncDown : public FuncSetMultivar<Param> {
 protected:
  char* fixedParamsDown;
  
 public:
  FuncDown() {};
  virtual ~FuncDown()
    {  
      for (int i=0; i<len; i++)
	delete[] function[i];
      delete[] values;
    }
  FuncDown(Param& coordinate, int __len)  : 
    FuncSetMultivar<Param>(coordinate, __len) {}

  virtual void init(Param& coordinate, int __len, 
		    Domain* domain, int alphaVar) 
    {
      fixedParamsDown = domain->getFixedParamsDown();
      FuncSetMultivar<Param>::init(coordinate, __len);
      init(domain, alphaVar);
    } 
  
  virtual void init() {
    FuncSetMultivar<Param>::init();
  }
  
  virtual void init(Domain* domain, int alphaVar) {
    int index = 0;
    ifstream ifile;
    ifile.open(fixedParamsDown);
    if (domain->getOrbitalType() == "Hydrogen") {
      if (domain->getDown1s())  {function[index]=new Hydr1s<Param>;  index++;}
      if (domain->getDown2s())  {function[index]=new Hydr2s<Param>;  index++;}
      if (domain->getDown2px()) {function[index]=new Hydr2px<Param>; index++;}
      if (domain->getDown2py()) {function[index]=new Hydr2py<Param>; index++;}
      if (domain->getDown2pz()) {function[index]=new Hydr2pz<Param>; index++;}
      if (index != len ) cerr << "Error creating FuncUp!\nNot matching"  
			      << " dimensions of number particles spin up (" 
			      << len << ") and number of input functions\n";
      for (int i=0; i<len; i++)
	function[i]->attach(domain->getNumAlpha(), 
			    domain->getAlphaParam(alphaVar));
    } 
    else if (domain->getOrbitalType() == "HartreeFock") {
      for (int i=0; i<len; i++) {
	function[i] = new HF<Param>;
	function[i]->readHFparams(ifile);
      }
    }
    for (int i=0; i<len; i++)
      function[i]->setNumberDimensions(domain->getNumDimensions());
    ifile.close();
  }
};

#endif
\end{lstlisting}


\newpage




% *************************************************************
% *                                                           *
% *                  SINGLEPARTICLEFUNCS.H                    *
% *                                                           *
% *************************************************************
\subsection{SingleParticleFuncs.h}
\begin{lstlisting}
#ifndef SingleParticleFuncs_IS_INCLUDED
#define SingleParticleFuncs_IS_INCLUDED

#include <cmath>
#include <iostream>
#include <fstream>
#include "../Ref/Ref.h"
#include "../Coor/Coor.h"
#include "../Domain/Domain.h"
#include "../SolidHarmonics/SolidHarmonics.h"
#include "../STOBasis/STOBasis.h"

// ****************************************************************
// *                      SINGELPARTICLEFUNC                      *
// ****************************************************************
template <class Param>
class SingleParticleFunc {

 protected:
  double*  param;
  virtual  inline double phi(Param& coordinate) {return 0;}
  int      centerNr;
  int      currentNr;

 public:
  SingleParticleFunc() {}
  virtual ~SingleParticleFunc() {}
  virtual void   attach(int _numParams, double* _param) 
    { param=_param;}
  virtual void   setNumberDimensions(int numDimensions)
    { centerNr = 2*numDimensions;}
  virtual double operator()(Param& coordinate) 
    { currentNr = centerNr;
    return phi(coordinate);}
  virtual double operator()(Param& coordinate, int nr) 
    { currentNr = nr;
    return phi(coordinate);}
  virtual void readHFparams(ifstream& ifile) {;}
};


//************************************************************************
//*                  3-dimensional hydrogen orbitals                     *
//************************************************************************
//*********** Hydr1s *********
template <class Param>
class Hydr1s : public SingleParticleFunc<Param> {
 protected:
  virtual inline double phi(Param& coordinate) {
    return exp(- param[0] * coordinate.r(currentNr));
  }
 public:
  Hydr1s() {}
  virtual ~Hydr1s() {}
};
//*********** Hydr2s *********
template <class Param>
class Hydr2s : public SingleParticleFunc<Param> {
 protected:
  virtual inline double phi(Param& coordinate) {
    return ((2 - param[0]*coordinate.r(currentNr)) * exp(-0.5*coordinate.r(currentNr)));
  }
 public:
  Hydr2s() {}
  virtual ~Hydr2s() {}
};
//*********** Hydr2px *********
template <class Param>
class Hydr2px : public SingleParticleFunc<Param> {
 protected:
  virtual inline double phi(Param& coordinate) {
    return param[0]*coordinate(0, currentNr) * exp(-0.5*coordinate.r(currentNr)*param[0]);
  }
 public:
  Hydr2px() {}
  virtual ~Hydr2px() {}
};
//*********** Hydr2py *********
template <class Param>
class Hydr2py : public SingleParticleFunc<Param> {
 protected:
  virtual inline double phi(Param& coordinate) {
    return param[0]*coordinate(1, currentNr) * exp(-0.5*coordinate.r(currentNr)*param[0]);
  }
 public:
  Hydr2py() {}
  virtual ~Hydr2py() {}
};
//*********** Hydr2pz *********
template <class Param>
class Hydr2pz : public SingleParticleFunc<Param> {
 protected:
  virtual inline double phi(Param& coordinate) {
    return param[0]*coordinate(2, currentNr) * exp(-0.5*coordinate.r(currentNr)*param[0]);
  }
 public:
  Hydr2pz() {}
  virtual ~Hydr2pz() {}
};


//************************************************************************
//*                3-dimensional Hartree-Fock orbitals                   *
//************************************************************************
//
template <class Param>
class HF : public SingleParticleFunc<Param> {
 protected:
  double*                     coefficients;
  int                         numCoeff;
  int                         numParams;
  Ref<SolidHarmonics<Param> > solidHarmonics;
  Ref<STOBasis<Param> >       STOfuncs;

  virtual inline double z1(Param& coordinate) {return 0;}
  virtual inline double z2(Param& coordinate) {return 0;}
  virtual inline double z3(Param& coordinate) {return 0;}
  virtual inline double z4(Param& coordinate) {return 0;}
  virtual inline double z5(Param& coordinate) {return 0;}
  virtual inline double z6(Param& coordinate) {return 0;}
  virtual inline double z7(Param& coordinate) {return 0;}
  virtual inline double z8(Param& coordinate) {return 0;}
  virtual inline double z9(Param& coordinate) {return 0;}
  virtual inline double z10(Param& coordinate) {return 0;}

  virtual inline double phi2(Param& coordinate) {
    return param[0]*z1(coordinate) + param[1]*z2(coordinate) +
      param[2]*z3(coordinate) + param[3]*z4(coordinate) +
      param[4]*z5(coordinate) + param[5]*z6(coordinate);
  }
  virtual inline double phi(Param& coordinate) {
    double result = 0;
    for (int i=0; i<numCoeff; i++) 
      result += coefficients[i] * solidHarmonics()(coordinate,i, currentNr) 
	* STOfuncs()(coordinate, i, currentNr);
    return result;
  }
 public:
  HF() {}

  virtual void readHFparams(ifstream& ifile) 
    {
      ifile >> numCoeff;

      int*    OrbN = new int[numCoeff];
      int     OrbL;
      int     OrbM;
      double* Xsi  = new double[numCoeff];
      coefficients = new double[numCoeff];

      for (int i=0; i<numCoeff; i++)
	ifile >> OrbN[i];
      ifile >> OrbL;
      ifile >> OrbM;
      for (int i=0; i<numCoeff; i++)
	ifile >> Xsi[i];
      for (int i=0; i<numCoeff; i++)
	ifile >> coefficients[i];

      solidHarmonics = new SolidHarmonics<Param>;
      STOfuncs       = new STOBasis<Param>;
      solidHarmonics().init(numCoeff, OrbL, OrbM);
      STOfuncs().init(numCoeff, OrbN, OrbL, Xsi);
      delete OrbN;
      delete Xsi;
    }
};

#endif
\end{lstlisting}



\newpage



% *************************************************************
% *                                                           *
% *                         STOBASIS.H                        *
% *                                                           *
% *************************************************************
\subsection{STOBasis.h}
\begin{lstlisting}
#ifndef STOBasis_IS_INCLUDED
#define STOBasis_IS_INCLUDED

#include "../STOBasisFuncs/STOBasisFuncs.h"

// ****************************************************************
// *                          STOBASIS                            *
// ****************************************************************
template <class Param>
class STOBasis {

 protected:
  STOBasisFuncs<Param>* STOfuncs;
  double constant, expConst;

 public:
  STOBasis() {}
  void init(int num, int* orbN, int orbL, double* Xsi) 
    {
      STOfuncs    = new STOBasisFuncs<Param>[num];
      for (int i=0; i<num; i++) 
	STOfuncs[i].initConsts(orbN[i], orbL, Xsi[i]);
    }

  virtual double operator ()(Param& coordinate, int num, int currentNumber)
    { return STOfuncs[num](coordinate, currentNumber); }

};

#endif
\end{lstlisting}

% *************************************************************
% *                                                           *
% *                     STOBasisFuncs.h                       *
% *                                                           *
% *************************************************************
\subsection{STOBasisFuncs.h}
\begin{lstlisting}
#ifndef STOBasisFuncs_IS_INCLUDED
#define STOBasisFuncs_IS_INCLUDED

// ****************************************************************
// *                        STOBASISFUNCS                         *
// ****************************************************************
template <class Param>
class STOBasisFuncs {

 protected:
  double constant, expConst, rExp, r;

 public:
  STOBasisFuncs() {}
  virtual void initConsts(int n, int l, double xsi)
    {
      rExp = n-l-1;
      expConst = -xsi;
      double faculty = 1;
      for (int i=1; i<2*n+1; i++) faculty*=i;
      constant = pow(2*xsi, n+0.5)/sqrt(faculty);
    }
  virtual double operator ()(Param& coordinate, int currentNumber)
    { 
      r = coordinate.r(currentNumber);
      return constant*pow(r,rExp)*exp(expConst*r);
    }

};

#endif
\end{lstlisting}



\newpage




% *************************************************************
% *                                                           *
% *                      SolidHarmonics.h                     *
% *                                                           *
% *************************************************************
\subsection{SolidHarmonics.h}
\begin{lstlisting}
#ifndef SolidHarmonics_IS_INCLUDED
#define SolidHarmonics_IS_INCLUDED

#include "../Domain/Domain.h"
#include <iostream>
#include <iomanip>
#include "../SolidHarmonicsFuncs/SolidHarmonicsFuncs.h"

#ifndef sqr_IS_INCLUDED
#define sqr_IS_INCLUDED
inline double sqr(double x) {return x*x;};
#endif

// ****************************************************************
// *                       SOLIDHARMONICS                         *
// ****************************************************************
template <class Param>
class SolidHarmonics {

 protected:
  SolidHarmonicsFuncs<Param>** SHfuncs;

 public:
  SolidHarmonics() {}
  void init(int num, int orbL, int orbM) 
    {
      SHfuncs    = new SolidHarmonicsFuncs<Param>*[num];
      for (int i=0; i<num; i++) {
	if ( (orbL == 0)&(orbM == 0) )
	  SHfuncs[i] = new SH00<Param>;
	else if ( (orbL == 1)&(orbM == -1) )
	  SHfuncs[i] = new SH1m1<Param>;
	else if ( (orbL == 1)&(orbM == 0) )
	  SHfuncs[i] = new SH10<Param>;
	else if ( (orbL == 1)&(orbM == 1) )
	  SHfuncs[i] = new SH1p1<Param>;
	else if ( (orbL == 2)&(orbM == -2) )
	  SHfuncs[i] = new SH2m2<Param>;
	else if ( (orbL == 2)&(orbM == -1) )
	  SHfuncs[i] = new SH2m1<Param>;
	else if ( (orbL == 2)&(orbM == 0) )
	  SHfuncs[i] = new SH20<Param>;
	else if ( (orbL == 2)&(orbM == 1) )
	  SHfuncs[i] = new SH2p1<Param>;
	else if ( (orbL == 2)&(orbM == 2) )
	  SHfuncs[i] = new SH2p2<Param>;
      }
    }
  virtual double operator ()(Param& coordinate, int num, int currentNumber)
    { return SHfuncs[num]->SH(coordinate, currentNumber); }

};

#endif
\end{lstlisting}


% *************************************************************
% *                                                           *
% *                    SolidHarmonicsFuncs.h                  *
% *                                                           *
% *************************************************************
\subsection{SolidHarmonicsFuncs.h}
\begin{lstlisting}
#ifndef SolidHarmonicsFuncs_IS_INCLUDED
#define SolidHarmonicsFuncs_IS_INCLUDED

#include "../Domain/Domain.h"
#include <iostream>
#include <iomanip>

#ifndef sqr_IS_INCLUDED
#define sqr_IS_INCLUDED
inline double sqr(double x) {return x*x;};
#endif


// ****************************************************************
// *                     SOLIDHARMONICSFUNCS                      *
// ****************************************************************
template <class Param>
class SolidHarmonicsFuncs {
 protected:
  double constant;
 public:
  SolidHarmonicsFuncs() {}
  virtual double SH(Param& coordinate, int currentNumber) {return 0;}
};

// ***************************** SH00 ****************************
template <class Param>
class SH00 : public SolidHarmonicsFuncs<Param> {
 public:
  SH00() {}
  virtual double SH(Param& coordinate, int currentNumber) {return 1;}
};

// **************************** SH1m1 ****************************
template <class Param>
class SH1m1 : public SolidHarmonicsFuncs<Param> {
 public:
  SH1m1() {}
  virtual double SH(Param& coordinate, int currentNumber) 
    {return coordinate(0, currentNumber);}
};

// ***************************** SH10 ****************************
template <class Param>
class SH10 : public SolidHarmonicsFuncs<Param> {
 public:
  SH10() {}
  virtual double SH(Param& coordinate, int currentNumber) 
    {return coordinate(2, currentNumber);}
};

// **************************** SH1p1 ****************************
template <class Param>
class SH1p1 : public SolidHarmonicsFuncs<Param> {
 public:
  SH1p1() {}
  virtual double SH(Param& coordinate, int currentNumber) 
    {return coordinate(1, currentNumber);}
};

// **************************** SH2m2 ****************************
template <class Param>
class SH2m2 : public SolidHarmonicsFuncs<Param> {
 public:
  SH2m2() {constant = 1/2*sqrt(3.);}
  virtual double SH(Param& coordinate, int currentNumber) 
    {return constant*(sqr(coordinate(0, currentNumber)) - sqr(coordinate(1, currentNumber)));}
};

// **************************** SH2m1 ****************************
template <class Param>
class SH2m1 : public SolidHarmonicsFuncs<Param> {
 public:
  SH2m1() {constant = sqrt(3.);}
  virtual double SH(Param& coordinate, int currentNumber) 
    {return constant*coordinate(0, currentNumber)*coordinate(2, currentNumber);}
};

// ***************************** SH20 ****************************
template <class Param>
class SH20 : public SolidHarmonicsFuncs<Param> {
 public:
  SH20() {}
  virtual double SH(Param& coordinate, int currentNumber) 
    {return (3*sqr(coordinate(2, currentNumber)) - sqr(coordinate.r(currentNumber)))/2;}
};

// **************************** SH2p1 ****************************
template <class Param>
class SH2p1 : public SolidHarmonicsFuncs<Param> {
 public:
  SH2p1() {constant = sqrt(3.);}
  virtual double SH(Param& coordinate, int currentNumber) 
    {return constant*coordinate(1, currentNumber)*coordinate(2, currentNumber);}
};

// **************************** SH2p2 ****************************
template <class Param>
class SH2p2 : public SolidHarmonicsFuncs<Param> {
 public:
  SH2p2() {constant = sqrt(3.);}
  virtual double SH(Param& coordinate, int currentNumber) 
    {return  constant*coordinate(0, currentNumber)*coordinate(1, currentNumber);}
};

#endif
\end{lstlisting}


\newpage




% *************************************************************
% *                                                           *
% *                         Jastrow.h                         *
% *                                                           *
% *************************************************************
\subsection{Jastrow.h}
\begin{lstlisting}
#ifndef Jastrow_IS_INCLUDED
#define Jastrow_IS_INCLUDED

#include "./../fFunction/fFunction.h"
#include "./../Distance/Distance.h"
#include "../SpinFactors/SpinFactors.h"
#include "../Domain/Domain.h"
#include "../Coor/Coor.h"
#include <blitz/array.h>

#include <iostream>
#include <cmath>
using namespace std;

class Jastrow {

 protected:
  Distance* distance;
  SpinFactors* spinFactors;

  fFunction* f;
  Domain* domain;

  CoorSpinDiff* coors;
  CoorSpinDiff* trialCoor;

  // Array of Upper matrix composed of the values of the function fij 
  Array<double, 2> jastrowMatrix;
  // The (new) values
  Array<double, 1> trialColumn, trialRow;
  Array<double, 1> trialDistanceColumn, trialDistanceRow;
  


  int numParticles;        // Number of particles.
  int Nm1;                 // numParticles - 1.
  int currentParticle;     // Particle proposed moved.
  double jastrowian;       // Value of J, G=J or G=exp(J).
  double difference;       // Value of deltaJ = Jnew - Jold.

  int* spinFlip;           // Boolean 0=noflip, 1=flip.
  int otherParticle;       // Particle to exchange spin with.
  double* newFactor;       // Values of either 1 or 1/2 to impose
                           // different cusp conditions.
  double* oldFactor;       // Same as above.
  double* otherDifference; // newFactor - oldFactor.

  void suggestMoveNoFlip();
  void calculateNoFlipDifference();
  void suggestMoveFlip();
  void calculateFlipDifference();

 public:
  Jastrow() {}
  void attach(Domain* _domain, fFunction* _f);
  void initialize();
  void setToNextParticle();
  void setCurrentParticle(int _currentParticle);
  void setOtherParticle(int _otherParticle) {otherParticle=_otherParticle;}
  void suggestMove();
  void acceptMove();
  void rejectMove() {}
  double& operator()();
  double getDifference();
  Array<double, 2> getJastrowMatrix() {return jastrowMatrix;}
  Array<double, 1> getTrialColumn()   {return trialColumn;}
  Array<double, 1> getTrialRow()      {return trialRow;}
};


class JastrowDiff{
  // The 2*d array, fij(xi_d+h) and fij(xi_d-h)
  DistanceDiff* distanceDiff;
  SpinFactors* spinFactors;
  fFunction* f;
  Domain* domain;
  CoorSpinDiff* coors;
  CoorSpinDiff* trialCoor;

  Array<double, 2> jastrowMatrixPlus, jastrowMatrixMinus;
  // The (new) values
  Array<double, 1> trialColumnPlus, trialRowPlus;
  Array<double, 1> trialColumnMinus, trialRowMinus; 
  Array<double, 1> trialDistanceColumn,  trialDistanceRow;

  int numParticles;    // Number of particles.
  int Nm1;             // numParticles - 1.
  int numDimensions;   // Number of dimensions.
  int currentParticle; // Particle proposed moved.

  int diffPlus;        // Index indicating with respect to which 
                       // Cartesian coordinate we wish to 
                       // perform positive differentiation
                       // (x(d=0), y(d=1), etc.) fij(xi_d+h).
                       // diffPlus = d.
  int diffMinus;       // Index indicating with respect to which 
                       // Cartesian coordinate we wish to
                       // perform nagative differentiation
                       // (x(d=0), y(d=1), etc.) fij(xi_d-h).
                       // diffPlus = d + numDimensions.

 public:
  JastrowDiff() {}
  void attach(Domain* _domain, fFunction* _f, int _differentiate);
  void initialize();
  void setToNextParticle();
  void setCurrentParticle(int _currentParticle);
  void suggestMove();
  void acceptMove();
  void rejectMove() {}
  Array<double, 2> getJastrowMatrixPlus()  {return jastrowMatrixPlus;}
  Array<double, 2> getJastrowMatrixMinus() {return jastrowMatrixMinus;}
};

#include "InlineJastrow.h"

#endif
\end{lstlisting}


% *************************************************************
% *                                                           *
% *                        Jastrow.cpp                        *
% *                                                           *
% *************************************************************
\subsection{Jastrow.cpp}
\begin{lstlisting}
#include "Jastrow.h"

// ****************************************************************
// *                           JASTROW                            *
// ****************************************************************
//
// *************************** attach *****************************
void Jastrow::attach(Domain* _domain, fFunction* _f) {
  domain           = _domain;
  spinFactors      = domain->getSpinFactors();
  distance         = domain->getDistance();
  f                = _f;
  numParticles     = domain->getNumParticles();
  Nm1              = numParticles - 1;

  jastrowMatrix.resize(numParticles, numParticles);
  trialColumn.resize(numParticles);
  trialRow.resize(numParticles);

  trialDistanceColumn.resize(numParticles);
  trialDistanceRow.resize(numParticles);

  spinFlip         = domain->getSpinFlip();
  newFactor        = spinFactors->getNewFactor();
  oldFactor        = spinFactors->getOldFactor();
  otherDifference  = spinFactors->getOtherDifference();

  coors            = domain->getCoors();
  trialCoor        = domain->getTrialCoor();
}


// ************************* initialize ***************************
void Jastrow::initialize() {

  Array<double, 2> interElectronicDistances 
    = distance->getInterElectronicDistances();
  for(int i=0; i<numParticles; i++)
    for (int j=0; j<numParticles; j++)
      jastrowMatrix(i,j) = (*f)( interElectronicDistances(i,j), 
				 coors[i].r(), coors[j].r());

  spinFactors->calculateMatrix();
  jastrowian = 0;
  int k=0;
  for(int i=0; i<numParticles-1; i++) {
    for (int j=i+1; j<numParticles; j++)
      jastrowian += jastrowMatrix(i,j) * spinFactors->getMatrix()[k++];
  }
  setCurrentParticle(0);
  difference = 0;
}


// ********************** setToNextParticle ***********************
void Jastrow::setToNextParticle() {
  currentParticle++;
  if (currentParticle==numParticles) currentParticle=0;
  difference = 0;
}


// ********************* setCurrentParticle ***********************
void Jastrow::setCurrentParticle(int _currentParticle) {
  currentParticle = _currentParticle;
  difference = 0;
}


// ************************ suggestMove ***************************
void Jastrow::suggestMove() {
  if (*spinFlip) suggestMoveFlip();
  else suggestMoveNoFlip();
}


// ********************** suggestMoveNoFlip ***********************
void Jastrow::suggestMoveNoFlip() {
  trialDistanceColumn = distance->getTrialColumn();
  trialDistanceRow    = distance->getTrialRow();
  for ( int i=0; i < currentParticle; i++ ) {
    trialColumn(i) = trialRow(i) =
      (*f)( trialDistanceColumn(i), coors[i].r(), trialCoor->r());
  }
  for ( int i=currentParticle+1; i < numParticles; i++ ) {
    trialColumn(i) = trialRow(i) =
      (*f)( trialDistanceColumn(i), trialCoor->r(), coors[i].r());
  }
  trialColumn(currentParticle) = trialRow(currentParticle) = 0;
  calculateNoFlipDifference();
}


// ****************** calculateNoFlipDifference *******************
void Jastrow::calculateNoFlipDifference() {
  difference = 0;
  for (int i = 0; i<currentParticle; i++)
    difference += 
      newFactor[i] * ( trialColumn(i) - jastrowMatrix(i, currentParticle) );
  for (int i = currentParticle+1; i < numParticles; i++ )
    difference += 
      newFactor[i-1] * ( trialColumn(i) - jastrowMatrix(i, currentParticle) );
}


// *********************** suggestMoveFlip ************************
void Jastrow::suggestMoveFlip() {
  trialDistanceColumn = distance->getTrialColumn();
  trialDistanceRow    = distance->getTrialRow();
  otherParticle = domain->getOtherParticle();
  for ( int i=0; i < currentParticle; i++ ) {
    trialColumn(i) = trialRow(i) =
      (*f)(trialDistanceColumn(i),  coors[i].r(), trialCoor->r());
  }
  for ( int i=currentParticle+1; i < numParticles; i++ ) {
    trialColumn(i) = trialRow(i) =
      (*f)( trialDistanceColumn(i), trialCoor->r(), coors[i].r());
  }
  trialColumn(currentParticle) = trialRow(currentParticle) = 0;
  calculateFlipDifference();
}


// ******************* calculateFlipDifference ********************
void Jastrow::calculateFlipDifference() {
  difference = 0;
  for (int i = 0; i<currentParticle; i++)
    difference += 
      newFactor[i] * trialColumn(i) 
      - oldFactor[i]*jastrowMatrix(i, currentParticle)
      + otherDifference[i] * jastrowMatrix(i, otherParticle);
  for (int i = currentParticle+1; i < numParticles; i++ )
    difference += 
      newFactor[i-1] * trialColumn(i) 
      - oldFactor[i] * jastrowMatrix(i, currentParticle)
      + otherDifference[i] * jastrowMatrix(i, otherParticle);
}


// ************************* acceptMove ***************************
void Jastrow::acceptMove() {
  Range N(0,Nm1);
  jastrowMatrix( currentParticle, N )  = trialColumn( N );
  jastrowMatrix( N , currentParticle ) = trialRow( N );

  jastrowian+=difference;
}


// ************************** operator ****************************
double& Jastrow::operator()() {
  return jastrowian;
}

// ************************ getDifference *************************
double Jastrow::getDifference() {
  return difference;
}



// ************   CLASS JastrowPropose   ************

// ****************************************************************
// *                         JASTROWDIFF                          *
// ****************************************************************
//
// *************************** attach *****************************
void JastrowDiff::attach(Domain* _domain, fFunction* _f, 
			 int _differentiate) {
  domain           = _domain;
  int differentiate    = _differentiate;
  distanceDiff     = &(domain->getDistanceDiff()[differentiate]);
  spinFactors      = domain->getSpinFactors();
  f                = _f;
  numParticles     = domain->getNumParticles();
  numDimensions    = domain->getNumDimensions();
  Nm1              = numParticles - 1;

  jastrowMatrixPlus.resize(numParticles, numParticles);
  jastrowMatrixMinus.resize(numParticles, numParticles);
  trialColumnPlus.resize(numParticles);
  trialRowPlus.resize(numParticles);
  trialColumnMinus.resize(numParticles);
  trialRowMinus.resize(numParticles);

  trialDistanceColumn.resize(numParticles);
  trialDistanceRow.resize(numParticles);

  coors            = domain->getCoors();     // HER
  trialCoor        = domain->getTrialCoor(); // HER
  diffPlus         = differentiate;
  diffMinus        = differentiate + numDimensions;
}


// ************************* initialize ***************************
void JastrowDiff::initialize() {
  Array<double, 2> interElectronicDistances(numParticles,numParticles);
  interElectronicDistances  = distanceDiff->getInterElectronicDistances();
  for(int i=0; i<numParticles; i++)
    for (int j=0; j<numParticles; j++)
      jastrowMatrixPlus(i,j) 
	= (*f)( interElectronicDistances(i,j), 
		coors[i].r(diffPlus), coors[j].r(diffPlus));
  for(int i=0; i<numParticles; i++)
    for (int j=0; j<numParticles; j++) {
      jastrowMatrixMinus(i,j) 
	= (*f)( interElectronicDistances(j,i), 
		coors[i].r(diffMinus), coors[j].r(diffMinus));
    }
  setCurrentParticle(0);
}


// ********************** setToNextParticle ***********************
void JastrowDiff::setToNextParticle() {
  currentParticle++;
  if (currentParticle==numParticles) currentParticle=0;
}


// ********************* setCurrentParticle ***********************
void JastrowDiff::setCurrentParticle(int _currentParticle) {
  currentParticle = _currentParticle;
}


// ************************ suggestMove ***************************
void JastrowDiff::suggestMove() {
  trialDistanceColumn = distanceDiff->getTrialColumn();
  trialDistanceRow    = distanceDiff->getTrialRow();
  for ( int i=0; i < currentParticle; i++ ) {
    trialColumnPlus(i) = 
      (*f)( trialDistanceColumn(i), coors[i].r(diffPlus)
	    , trialCoor->r());
    trialRowPlus(i) =
      (*f)( trialDistanceRow(i), coors[i].r()
	    , trialCoor->r(diffPlus));

    trialColumnMinus(i) = 
      (*f)( trialDistanceRow(i), coors[i].r(diffMinus)
	    , trialCoor->r());
    trialRowMinus(i) =
      (*f)( trialDistanceColumn(i), coors[i].r()
	    , trialCoor->r(diffMinus));
  }
  for ( int i=currentParticle+1; i < numParticles; i++ ) {
    trialColumnPlus(i) = 
      (*f)( trialDistanceColumn(i), trialCoor->r()
	    , coors[i].r(diffPlus) );
    trialRowPlus(i) =
      (*f)( trialDistanceRow(i), trialCoor->r(diffPlus), 
	    coors[i].r() );

    trialColumnMinus(i) = 
      (*f)( trialDistanceRow(i), trialCoor->r(), 
	    coors[i].r(diffMinus) );
    trialRowMinus(i) =
      (*f)( trialDistanceColumn(i) , trialCoor->r(diffMinus), 
	    coors[i].r());
  }
  trialColumnPlus(currentParticle)  = trialRowPlus(currentParticle)  = 0;
  trialColumnMinus(currentParticle) = trialRowMinus(currentParticle) = 0;

}


// ************************* acceptMove ***************************
void JastrowDiff::acceptMove() {
  Range N(0,Nm1);
  jastrowMatrixPlus( currentParticle, N )   = trialColumnPlus( N );
  jastrowMatrixPlus( N , currentParticle )  = trialRowPlus( N );

  jastrowMatrixMinus( currentParticle, N )  = trialColumnMinus( N );
  jastrowMatrixMinus( N , currentParticle ) = trialRowMinus( N );
}
\end{lstlisting}



\newpage




% *************************************************************
% *                                                           *
% *                     Correlation.h                         *
% *                                                           *
% *************************************************************
\subsection{Correlation.h}
\begin{lstlisting}
#ifndef Correlation_IS_INCLUDED
#define Correlation_IS_INCLUDED

#include "../Domain/Domain.h"
#include "../Jastrow/Jastrow.h"
#include "../Distance/Distance.h"
#include "../fFunction/fFunction.h"
#include "../SpinFactors/SpinFactors.h"
#include <blitz/array.h>

// ****************************************************************
// *                           CORREL                             *
// ****************************************************************
class Correl {

 protected:

  Domain*       domain;
  int           numParticles;    // Number of particles.
  int           Nm1;             // numParticles - 1.
  int           numDimensions;   // Number of dimension.

  int           currentParticle; // This is the particle that 
                                 // currently is (proposed) moved.
  int           otherParticle;   // Particle to exchange spin with.

  Distance*     distance;
  DistanceDiff* distanceDiff;
  Jastrow*      jastrow;
  JastrowDiff*  jastrowDiff;

  int           expBool;         // 0 G=J, 1 G=exp(J)
  double*       beta;            // Variational parameters
  double        ratio;           // Gnew/Gold
  fFunction*    f;               // J=sum(i<j) f(r_ij, r_i, r_j) 
  double        h, hDoubleInverse, hSquaredInverse; // For numerical 
                                                    // derivation
  double*       gradJastrow;     // The gradient of G divided by G
  double        laplacian;       // The Laplacian of G divided by G
  double        correlation;     // The value of G

  SpinFactors*  spinFactors;
  double*       spinFactorMatrix;

  Array<double, 2> jastrowMatrix;
  Array<double, 2> *jastrowMatrixPlus, *jastrowMatrixMinus;


 public:
  Correl();
  void attach(Domain& _domain);
  void attachFFunction(fFunction* _f);
  void createJastrowAndJastrowDiff();

  void setToNextParticle();
  void setCurrentParticle(int _currentParticle); 
  void setOtherParticle(int _otherParticle) 
    {otherParticle=_otherParticle;}

  // Algorithms for proposing a Metropolis step
  void suggestMove();
  // Thermalization spesific algorithms; prior to samle
  void initializeThermalization();
  void acceptThermalizedMove();
  void rejectThermalizedMove();
  // VMC spesific algorithms
  void initializeVMC();
  void acceptMove();
  void rejectMove();
  // Only applicabel prior to accepting move; 
  // returns either Jnew/Jold or exp(Jnew)/exp(Jold)
  void calculateRatio();
  double* getRatioPtr()               {return &ratio;}

  // Only applicable after accepting move; 
  // returns either J or exp(J)
  void    calculateGradAndLaplacianRatios();
  double* getGradRatio()              {return gradJastrow;}
  double* getLaplaceRatio()           {return &laplacian;}
  void    calculateCorrelation();
  double* getCorrelationPtr()         {return &correlation;}
  double  operator()();
};


#endif
\end{lstlisting}


% *************************************************************
% *                                                           *
% *                     Correlation.cpp                       *
% *                                                           *
% *************************************************************
\subsection{Correlation.cpp}
\begin{lstlisting}
#include "Correlation.h"

//*****************************************************************
//*                           CORREL                              *
//*****************************************************************
//
//*************************** Correl *******************************
Correl::Correl() {}


//*************************** attach ******************************
void Correl::attach(Domain& _domain) {
  domain          = &_domain;
  numParticles    = domain->getNumParticles();
  numDimensions   = domain->getNumDimensions();
  Nm1             = numParticles-1;
  f               = domain->getF();

  spinFactors     = domain->getSpinFactors();
  spinFactorMatrix= spinFactors->getMatrix();

  gradJastrow                  = new double[numParticles*numDimensions];

  distance        = domain->getDistance();
  distanceDiff    = domain->getDistanceDiff();
  h               = domain->getH();
  hDoubleInverse  = 1./2./h;
  hSquaredInverse = 1./h/h;
}


//*********************** attachFFunction *************************
void Correl::attachFFunction(fFunction* _f) {
  f = _f;
  expBool=f->getExpBool();
}


//****************** createJastrowAndJastrowDiff ******************
// Create jastrow and jastrowDiff 
// NB: This must be preformed AFTER create/attachDistanceAndDistanceDiff 
//     AND AFTER createFBeta/attachFFunction
void Correl::createJastrowAndJastrowDiff() {
  // Create jastrow and jastrowDiff
  jastrow           = new Jastrow[1];
  jastrow->attach(domain, f);
  jastrowDiff       = new JastrowDiff[ numDimensions ]; 
  for (int i=0; i<numDimensions; i++)
      jastrowDiff[i].attach(domain, f, i);
  jastrowMatrix.resize(numParticles, numParticles);
  jastrowMatrixPlus  = new Array<double, 2>[3];
  jastrowMatrixMinus = new Array<double, 2>[3];
  for (int i=0; i<numDimensions; i++) {
    jastrowMatrixPlus[i].resize(numParticles, numParticles);
    jastrowMatrixMinus[i].resize(numParticles, numParticles);
  }
}



//***********************setToNextParticle ************************
void Correl::setToNextParticle() {
  currentParticle++;
  if (currentParticle==numParticles) currentParticle=0;
  jastrow->setToNextParticle();
  for (int i=0; i<numDimensions; i++)
    jastrowDiff[i].setToNextParticle();
}


//********************* setCurrentParticle ************************
void  Correl::setCurrentParticle(int _currentParticle){
  currentParticle=_currentParticle;
  jastrow->setCurrentParticle(currentParticle);
  for (int i=0; i<numDimensions; i++)
    jastrowDiff[i].setCurrentParticle(currentParticle);
}


//************************* suggestMove ***************************
void Correl::suggestMove() {
  jastrow->suggestMove();
  calculateRatio();
}


//******************* initializeThermalization ********************
void Correl::initializeThermalization() {
  jastrow->initialize();
  currentParticle=0;
}


//******************** acceptThermalizedMove **********************
void Correl::acceptThermalizedMove() {
  jastrow->acceptMove();
}


//******************** rejectThermalizedMove **********************
void Correl::rejectThermalizedMove() {
  jastrow->rejectMove();
}


//************************ initializeVMC **************************
void Correl::initializeVMC() {
  for (int i=0; i<numDimensions; i++)
    jastrowDiff[i].initialize();
  spinFactors->calculateMatrix();
  setCurrentParticle(0);
}


//************************** acceptMove ***************************
void Correl::acceptMove() {
  for (int i=0; i<numDimensions; i++)
    jastrowDiff[i].suggestMove();
  acceptThermalizedMove();
  for (int i=0; i<numDimensions; i++)
    jastrowDiff[i].acceptMove();
}


//************************** rejectMove ***************************
void Correl::rejectMove() {
  rejectThermalizedMove();
  for (int i=0; i<numDimensions; i++)
    jastrowDiff[i].rejectMove();
}


//*************** calculateGradAndLaplacianRatios *****************
void Correl::calculateGradAndLaplacianRatios() {

  laplacian = 0.0;
  int gjIndex = 0;
  double J = 1;
  if (!expBool) J = (*jastrow)();
  for (int i=0; i<numParticles; i++) {
    for (int k=0; k<numDimensions; k++) {
      jastrowMatrixPlus[k]  = jastrowDiff[k].getJastrowMatrixPlus();
      jastrowMatrixMinus[k] = jastrowDiff[k].getJastrowMatrixMinus();

      double gradPlus = 0, gradMinus = 0;
      int t=Nm1;
      int l=i-1;
      for (int j=0; j<i; j++) {
	gradPlus  += spinFactorMatrix[l]*jastrowMatrixPlus[k](j,i);
	gradMinus += spinFactorMatrix[l]*jastrowMatrixMinus[k](j,i);
	l += --t;
      }
      for (int j=i+1; j<numParticles; j++) {
	l++;
	gradPlus  += spinFactorMatrix[l]*jastrowMatrixPlus[k](j,i);
	gradMinus += spinFactorMatrix[l]*jastrowMatrixMinus[k](j,i);
      }
      gradJastrow[gjIndex++] = (gradMinus-gradPlus)*hDoubleInverse/J;
      laplacian += gradPlus + gradMinus;
    }
  }

  jastrowMatrix = jastrow->getJastrowMatrix();

  double grad = 0;
  for (int i=0; i<numParticles; i++) {
    int k=Nm1;
    int l=i-1;
    for (int j=0; j<i; j++) {
      grad  += spinFactorMatrix[l]*jastrowMatrix(j,i);
      l += --k;
    }
    for (int j=i+1; j<numParticles; j++) {
      l++;
      grad  += spinFactorMatrix[l]*jastrowMatrix(j,i);
    }
  }

  laplacian -= numDimensions*2.*grad;
  laplacian *= hSquaredInverse/J;

  if (expBool)
    for (int i=0; i<numParticles*numDimensions; i++) 
        laplacian += sqr( gradJastrow[i] );

}


//************************ calculateRatio *************************
// Only applicabel prior to accepting move
void Correl::calculateRatio() {
  if (expBool) { ratio = exp( (*jastrow).getDifference() );}
  else { ratio =  ((*jastrow)()-(*jastrow).getDifference())/(*jastrow)(); }
}


//********************* calculateCorrelation **********************
// To be used to get direct access to the value of the correlation
void Correl::calculateCorrelation() {
  if (expBool) {correlation = exp( (*jastrow)() );}
  else {correlation = (*jastrow)(); }  
}


//*************************** operator ****************************
// Only applicable after accepting move
double Correl::operator()() {
  if (expBool) {return correlation = exp( (*jastrow)() );}
  else {return correlation =  (*jastrow)(); }
}
\end{lstlisting}



\newpage



% *************************************************************
% *                                                           *
% *                      fFunction.h                          *
% *                                                           *
% *************************************************************
\subsection{fFunction.h}
\begin{lstlisting}
#ifndef fFunction_IS_INCLUDED
#define fFunction_IS_INCLUDED

#include <string>
#include <iostream>
#include <cstdio>
using namespace std;

// ****************************************************************
// *                          FFUNCTION                           *
// ****************************************************************
class fFunction {
protected:
  int     numberParams;  // Number of parameters
  double* params;        // Array of parameters
  int     expBool;       // If correlation G=J;           expBool=0
                         // Else if correlation G=exp(J); expBool=1

  virtual inline double   f(double rij, double ri, double rj)          
    {return 0;}
  virtual inline double   R(double r, int paramNumber) 
    {return 0;}
  double R_IJ, R_I, R_J;

public:
  fFunction() {}
  virtual void    attach(int _numberParams, double* _params, 
			 int _expBool) {
    numberParams = _numberParams;
    params       = _params;
    expBool      = _expBool;
  }
  virtual int     getExpBool()           {return expBool;}
  virtual double* getParams()            {return params;}
  virtual int     getNumberParams()      {return numberParams;}
  virtual double  operator()(double rij, double ri, double rj) 
    {return f(rij, ri, rj);}
};

//**************************** fNone ******************************
class fNone : public fFunction {
protected:
  virtual inline double f(double rij, double ri, double rj) {return 1.;}

public:
  fNone() {}
};

//**************************** fBeta ******************************
class fBeta: public fFunction {
protected:
  virtual inline double   f(double rij, double ri, double rj) 
    { return 0.5*rij/(1+params[0]*rij);}

public:
  fBeta() {}
};

//**************************** fBeta2 *****************************
class fBeta2: public fFunction {
protected:
  virtual inline double   f(double rij, double ri, double rj) 
    {return params[1]*rij/(1+params[0]*rij);}
public:
  fBeta2() {}
};

//**************************** fBeta3 *****************************
class fBeta3: public fFunction {
protected:
  virtual inline double   f(double rij, double ri, double rj) 
    {return params[1]*rij/(1+params[0]*rij+params[2]*rij*rij);}
public:
  fBeta3() {}
};

//*************************** fBeta2r2 ****************************
class fBeta2r2: public fFunction {
protected:
  virtual inline double f(double rij, double ri, double rj) 
    {return rij/(1+params[0]*rij+params[1]*rij*rij);}

public:
  fBeta2r2() {}
};

//************************** fExtended ****************************
class fExtended: public fFunction {

protected:
  virtual inline double R(double r, int paramNumber) 
    {
      double pr = params[paramNumber]*r;
      return r/(1+pr);
    }

  virtual inline double f(double rij, double ri, double rj) 
    {
      R_IJ = R(rij, 0); R_I = R(ri, 1); R_J = R(rj, 1); 
      return 
	// e-e:                                 // m n o
	params[2]*R_IJ                          // 0 0 1
	+ params[3]*R_IJ*R_IJ                   // 0 0 2

	// e-n:                                 // m n o
	+ params[4]*(R_I+R_J)                   // 1 0 0
	+ params[5]*(R_I*R_I+R_J*R_J)           // 2 0 0

	// e-e-n:                               // m n o
	+ params[6]*R_I*R_I*R_J*R_J             // 2 2 0
	+ params[7]*R_IJ*R_IJ*(R_I*R_I+R_J*R_J) // 2 0 2
	;
    }

public:
  fExtended() {}
};

#endif
\end{lstlisting}


\newpage



% *************************************************************
% *                                                           *
% *                     LocalWaveFunction.h                   *
% *                                                           *
% *************************************************************
\subsection{LocalWaveFunction.h}
\begin{lstlisting}
#ifndef LocalWaveFunction_IS_INCLUDED
#define LocalWaveFunction_IS_INCLUDED

#include "../Domain/Domain.h"
#include <iostream>
#include <iomanip>

// ****************************************************************
// *                      LOCALWAVEFUNCTION                       *
// ****************************************************************
class LocalWaveFunction {

 protected:

  ofstream *outputFile;

  int     numParticles;     // Number of particles.
  int     numDimensions;    // Number of dimension.
  int     prodPartDim;      // numParticles * numDimensions.

  double* centralSlater;    // Pointer to the value of the central 
                            // Slater-determinant.
  double* localSlater;      // Pointer to the value of the local
                            // Slater-determinant.
  double* localDiffSlater;  // Pointer to the gradient of the Slater-
                            // determinent to the Slater-deterimant.
  double* localDDiffSlater; // Pointer to the Laplacian of the Slater-
                            // determinent to the Slater-deterimant.
  int     numAlpha;         // Number of Slater-determinant parameters.
  double* alphaParams;      // Pointer to the local Slater-determinant 
                            // parameters.

  double* centralCorrelation;    // Pointer to the value of the  
                                 // central correlation G.
  double* localCorrelation;      // Pointer to the value of the local
                                 // correlation G.
  double* localDiffCorrelation;  // Pointer to the gradient of the 
                                 // correlation to the correlation.
  double* localDDiffCorrelation; // Pointer to the Laplacian of the 
                                 // correlation to the correlation.
  int     numBeta;               // Number of correlation parameters.
  double* betaParams;            // Pointer to the local  correlation
                                 // parameters.

  double  norm;                  // localSlater*localCorrelation/ 
                                 // (centralSlater*centralCorrelation).
  double  kineticEnergy;         // The kinetic energy.

  int     numSamples;            // Keep track of the number of samples.
  double  accumulatedEnergy;     // Sum of local energies E_L
  double  accumulatedEnergySquared; // Sum of E_L*E_L
  double  accumulatedNorm;       // Sum of the norms
  double  accumulatedVariance;   // Sum of (E_L - E_ref - deltaE)^2

  // Blocks are included to give an estimate of the true standard 
  // deviation of the energy. This approch is due to auto-correltion 
  // effects. The results should be tested by for example producing 
  // several independent VMC runs, and finding their standard 
  // deviation.
  int     numBlocks;             // The actual number of blocks.
  int     maxNumBlocks;          // Number of blocks allocated.
  int*    blockSize;             // Number of samples per block.
  int*    currentBlockNum;       // Index used for performing block
                                 // sampling.
  int*    numSamplesBlock;       // The number of samples for in each
                                 // of the different blocks.
  double* accumulatedEnergyBlock;// The sum of the energy samples for
                                 // the individual blocks.
  double* accumulatedEnergySquaredBlock; // The sum of the square of the
                                         // block-energies.
  double* accumulatedNormBlock;  // Sum of the norms for each block.
  double* tempEnergyBlock;       // Accumulates energies for a sample.
  double* tempNormBlock;         // Accumulates norms to a sample.

  int     varianceOptimization;  // Boolean determining whether we 
                                 // optimize with respect to energy(0) 
                                 // or variance(1).
  int     setWeightToUnity;      // Boolean true(1) weights (the norms)
                                 // are set to unity.
  double  referenceEnergy;       // Reference energy, E_ref (used for
                                 // variance optimization).
  double  deltaE;                // Small energry displacement (used
                                 // for variance optimization).

  void    calculateNorm();
  void    calculateKineticEnergy();
  void    allocateBlocks();
  double  getAverageEnergyBlock(int block);
  double  getStandardDeviationBlock(int block);
  void    addBlock(int _blockSize);
  void    deleteBlocks();

 public:
  LocalWaveFunction() {}
  void    init();
  void    initialize(Domain* domain);
  void    attachCentralSlaterDet(double* _centralSlaterDet);
  void    attachCentralCorrelation(double* _centralCorrelation);
  void    attachSlater(double* _localSlater, 
		     double* _localDiffSlater,
		     double* _localDDiffSlater, 
		       double* _alphaParams);
  void    attachCorrelation(double* _localCorrelation, 
			    double* _localDiffCorrelation,
			    double* _localDDiffCorrelation, 
			    double* _betaParams);
  void    sample(double potentialEnergy);
  void    summary();

  double  getAverageEnergy();
  double  getStandardDeviation();
  void    setReferenceEnergy(double E) {referenceEnergy=E;}
  double  getVariance();

  double* getAlphaParams() {return alphaParams;}
  double* getBetaParams()  {return betaParams;}
};

#endif
\end{lstlisting}



% *************************************************************
% *                                                           *
% *                    LocalWaveFunction.cpp                  *
% *                                                           *
% *************************************************************
\subsection{LocalWaveFunction.cpp}
\begin{lstlisting}
#include "LocalWaveFunction.h"

// ****************************************************************
// *                      LOCALWAVEFUNCTION                       *
// ****************************************************************
//
// Keeps track of one local variation
//
// **************************** init ******************************
void LocalWaveFunction::init() {
  numSamples                = 0;
  accumulatedEnergy         = 0;
  accumulatedEnergySquared  = 0;
  accumulatedNorm           = 0;
  accumulatedVariance       = 0;
}


// ************************* initialize ***************************
void LocalWaveFunction::initialize(Domain* domain) {
  numParticles              = domain->getNumParticles();
  numDimensions             = domain->getNumDimensions();
  prodPartDim               = numParticles*numDimensions;
  numAlpha                  = domain->getNumAlpha();
  numBeta                   = domain->getNumBeta();
  outputFile                = domain->getOutputFile();

  setWeightToUnity          = domain->getSetWeightToUnity();
  varianceOptimization      = domain->getVarianceOptimization();
  referenceEnergy           = domain->getReferenceEnergy();
  deltaE                    = domain->getDeltaE();

  init();
  deleteBlocks();
  maxNumBlocks              = 15;
  allocateBlocks();

  addBlock(2);
  addBlock(5);
  addBlock(10);
  addBlock(20);
  addBlock(25);

  addBlock(50);
  addBlock(100);
  addBlock(200);
  addBlock(500);
  addBlock(1000);

  addBlock(2000);
  addBlock(5000);
  addBlock(10000);
  addBlock(20000);
  addBlock(50000);
}


// *********************** allocateBlocks *************************
void LocalWaveFunction::allocateBlocks() {
  blockSize                     = new int[maxNumBlocks];
  currentBlockNum               = new int[maxNumBlocks];
  numSamplesBlock               = new int[maxNumBlocks];
  accumulatedEnergyBlock        = new double[maxNumBlocks];

  accumulatedEnergySquaredBlock = new double[maxNumBlocks];
  accumulatedNormBlock          = new double[maxNumBlocks];
  tempEnergyBlock               = new double[maxNumBlocks];
  tempNormBlock                 = new double[maxNumBlocks];
}


// ******************** attachCentralSlaterDet ********************
// Central == the origin of the local variation
// centralSlaterDet = pointer to the value of the central SD
void LocalWaveFunction::attachCentralSlaterDet(double* _centralSlater) {
  centralSlater   = _centralSlater;
}


// ****************** attachCentralCorrelation ********************
// Central == the origin of the local variation
// centralCorrelation = pointer to the value of the central 
// correlation
void LocalWaveFunction::attachCentralCorrelation(double* _centralCorrelation) {
  centralCorrelation = _centralCorrelation;
}


// ************************ attachSlater **************************
// These are the values of the (varied) SD
void LocalWaveFunction::attachSlater(double* _localSlater, 
				     double* _localDiffSlater,
				     double* _localDDiffSlater, 
				     double* _alphaParams) {
  localSlater      = _localSlater;
  localDiffSlater  = _localDiffSlater;
  localDDiffSlater = _localDDiffSlater;
  alphaParams      = _alphaParams;
}


// ********************* attachCorrelation ************************
void LocalWaveFunction::attachCorrelation(double* _localCorrelation, 
					  double* _localDiffCorrelation,
					  double* _localDDiffCorrelation, 
					  double* _betaParams) {
  localCorrelation      = _localCorrelation;
  localDiffCorrelation  = _localDiffCorrelation;
  localDDiffCorrelation = _localDDiffCorrelation;
  betaParams            = _betaParams;
}


// ************************ calculateNorm *************************
void LocalWaveFunction::calculateNorm() {
  if (setWeightToUnity) norm=1;
  else {
    norm =  (*localSlater)*(*localCorrelation) 
      /(*centralSlater)/(*centralCorrelation);
    norm *= norm;
  }
}


// ******************** calculateKineticEnergy ********************
void LocalWaveFunction::calculateKineticEnergy() {
  kineticEnergy = -0.5*( (*localDDiffSlater) + (*localDDiffCorrelation) )
    - dotProduct(localDiffSlater, localDiffCorrelation, prodPartDim);
}


// *************************** sample *****************************
void  LocalWaveFunction::sample(double potentialEnergy ) {
  calculateNorm();
  calculateKineticEnergy();
  numSamples                += 1;
  double localEnergy      = kineticEnergy + potentialEnergy;
  double localEnergyNorm  = localEnergy*norm;
  double localEnergy2norm = localEnergyNorm*localEnergy;

  accumulatedEnergy         += localEnergyNorm;
  accumulatedEnergySquared  += localEnergy2norm;
  accumulatedNorm           += norm;
  accumulatedVariance       
    += pow(localEnergy-referenceEnergy-deltaE, 2)*norm;
  for (int i=0; i<numBlocks; i++) {
    tempEnergyBlock[i]        += localEnergy;
    tempNormBlock[i]          += norm;
    if (++currentBlockNum[i]==blockSize[i]) {
      currentBlockNum[i]=0;
      numSamplesBlock[i]+=1;
      double averageNorm   =tempNormBlock[i]/blockSize[i];
      accumulatedNormBlock[i] +=averageNorm;
      double averageEnergy = tempEnergyBlock[i]/blockSize[i];
      accumulatedEnergyBlock[i] +=averageEnergy*averageNorm;
      accumulatedEnergySquaredBlock[i]
	+=averageEnergy*averageEnergy*averageNorm;
      tempEnergyBlock[i]=tempNormBlock[i]=0;     
    }
  }
}


// ********************** getAverageEnergy ************************
double LocalWaveFunction::getAverageEnergy() {
  return accumulatedEnergy/accumulatedNorm;
}


// ******************** getStandardDeviation **********************
double LocalWaveFunction::getStandardDeviation() {
  return sqrt ( (accumulatedEnergySquared/accumulatedNorm 
		- pow( accumulatedEnergy/accumulatedNorm, 2) ) / numSamples);
}


// ************************* getVariance **************************
double LocalWaveFunction::getVariance() {
  return sqrt ( (accumulatedVariance/accumulatedNorm)
		/ numSamples);
}


// ******************** getAverageEnergyBlock *********************
double LocalWaveFunction::getAverageEnergyBlock(int block) {
  return accumulatedEnergyBlock[block]/accumulatedNormBlock[block];
}


// ****************** getStandardDeviationBlock *******************
double LocalWaveFunction::getStandardDeviationBlock(int block) {
  return sqrt ( (accumulatedEnergySquaredBlock[block]
		 /accumulatedNormBlock[block] 
		- pow( accumulatedEnergyBlock[block]
		       /accumulatedNormBlock[block], 2) ) 
		/ numSamplesBlock[block]);
}


// ************************** addBlock ****************************
void LocalWaveFunction::addBlock(int _blockSize) {
  if (numBlocks<maxNumBlocks) {
    blockSize[numBlocks]                     = _blockSize;
    currentBlockNum[numBlocks]               = 0;
    accumulatedEnergyBlock[numBlocks]        = 0;
    accumulatedEnergySquaredBlock[numBlocks] = 0;
    accumulatedNormBlock[numBlocks]          = 0;
    tempEnergyBlock[numBlocks]               = 0;
    tempNormBlock[numBlocks]                 = 0;
    numSamplesBlock[numBlocks]               = 0;
    numBlocks++;
  }
  else
    *outputFile << "Could not create an additional block in LocalWaveFunction.\n" 
		<< "Maximun number of blocks set to " << maxNumBlocks 
		<< " (in code).\n";
}


// ************************ deleteBlocks **************************
void LocalWaveFunction::deleteBlocks() {
  numBlocks=0;
}


// *************************** summary ****************************
void LocalWaveFunction::summary() {
  *outputFile << "*** Alpha = [ ";
  for (int i=0; i<numAlpha; i++)
    *outputFile << setw(5) << alphaParams[i] << " ";
  *outputFile << "]  Beta = [ ";
  for (int i=0; i<numBeta; i++)
    *outputFile << setw(5) << betaParams[i] << " ";
  *outputFile << "]" <<  " Energy = " << setw(12) << getAverageEnergy()
	      << " " << setw(12) << getStandardDeviation();
  if (varianceOptimization) *outputFile << " Variance = " << setw(12) 
					<< getVariance();
  *outputFile << " ***" <<endl;
  *outputFile << "Blocksize ";
  for (int i=0; i<numBlocks; i++) 
    *outputFile << setw(9) << blockSize[i] << " ";
  *outputFile << "\n";
  *outputFile << "S.d.        [ ";
  for (int i=0; i<numBlocks; i++)
    *outputFile << setw(9) << getStandardDeviationBlock(i) << " ";
  *outputFile << "]\n";
}
\end{lstlisting}


\newpage


% *************************************************************
% *                                                           *
% *                        Variations.h                       *
% *                                                           *
% *************************************************************
\subsection{Variations.h}
\begin{lstlisting}
#ifndef Variations_IS_INCLUDED
#define Variations_IS_INCLUDED

#include "../Domain/Domain.h"
#include "../Correlation/Correlation.h"
#include "../SlaterDet/SlaterDet.h"
#include "../Ref/Ref.h"
#include "../fFunction/fFunction.h"
#include "../LocalWaveFunction/LocalWaveFunction.h"
#include "../SpinFactors/SpinFactors.h"

// ****************************************************************
// *                          VARIATIONS                          *
// ****************************************************************
template <class SlaterDeterminant>
class Variations {

 protected:

  ofstream* outputFile;
  fFunction*  f;

  int       numSlaterVariations;   // Number of variations in the
                                   // Slater-determinant parameter 
                                   // subspace. 
  int       numCorrelVariations;   // Number of variations in the
                                   // correlation parameter subspace.
  int       numVariations;         // Total number of variations.
  int       numParticles;          // Number of particles.

  int       centralSlater;         // Index specifying which of the 
                                   // Slater-variations we vary about.
  int       centralCorrel;         // Index specifying which of the 
                                   // correlation-variations we vary 
                                   // about.

  int       allowSpinFlip;         // Boolean indicating whether we 
                                   // allow(1) spin-flip or not(0).
  int       varianceOptimization;  // Boolean indicating whether we
                                   // optimize the paramters with 
                                   // respect to energy or variance
                                   // minimization.

  Ref<Domain>            domain;
  Ref<Correl>            correlation;
  Ref<SlaterDeterminant> slaterDeterminant;

  LocalWaveFunction*     localWaveFunctions;
  Correl*                correl;
  SlaterDeterminant*     slater;

  void                   createCorrel();
  void                   createSlaterDet();
  void                   createLocalSurface();

 public:
  Variations(Domain& _domain);
  void   setToNextParticle();
  void   setCurrentParticle(int _currentParticle);

  void   initializeThermalization(); // Called prior to starting the 
                                     // thermalization procedure.
  void   initializeVMC();            // Called in-between thermalization
                                     // and the actual VMC.
  void   initNewVmcRun();            // Called when subsequent VMC runs
                                     // are performed (after one VMC run
                                     // is finished and before next 
                                     // thermalization).

  void   suggestMove();
  void   acceptThermalization();
  void   rejectThermalization();
  void   acceptMove();
  void   rejectMove();

  void   sample();                   // One sample of the energy.
  void   summary();                  // Prints all the different local
                                     // variations to outputFile.
  void   summaryLowest();            // Prints all the lowest local
                                     // variation to outputFile (with
                                     // lowest we mean either lowest 
                                     // energy or variance).

  SlaterDeterminant& getSlaterDet()        {return slaterDeterminant();}
  Correl&            getCorrelation()      {return correlation();}

  int    findLowestWaveFunction();   // Finds the index corresponding 
                                     // to the lowest local variation.
  double getLowestEnergy();          // Find the energy corresponding 
                                     // to the lowest local variation.
  double getLowestVariance();        // Find the variance corresponding 
                                     // to the lowest local variation.
  double *getLowestAlphaParams();    // Find the Slater-paramters
                                     // corresponding to the lowest 
                                     // local variation.
  double *getLowestBetaParams();     // Find the correlation-paramters
                                     // corresponding to the lowest 
                                     // local variation.
  void setReferenceEnergy(double E); // Changes reference energy to E.

};

#include "Variations.cpp"


#endif
\end{lstlisting}



% *************************************************************
% *                                                           *
% *                       Variations.cpp                      *
% *                                                           *
% *************************************************************
\subsection{Variations.cpp}
\begin{lstlisting}
#ifndef VariationCPP_IS_INCLUDED
#define VariationCPP_IS_INCLUDED

#include "Variations.h"



// ****************************************************************
// *                          VARIATIONS                          *
// ****************************************************************
//
// ************************** Vatiations **************************
template <class SlaterDeterminant>
Variations<SlaterDeterminant>::Variations(Domain& _domain) : domain(_domain) { 
  numParticles         = domain().getNumParticles();
  numSlaterVariations  = domain().getNumSlaterVariations();
  numCorrelVariations  = domain().getNumCorrelVariations();
  allowSpinFlip        = domain().getAllowSpinFlip();
  outputFile           = domain().getOutputFile();
  varianceOptimization = domain().getVarianceOptimization();

  createSlaterDet();
  createCorrel();
  createLocalSurface();
}


// *********************** createSlaterDet ************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::createSlaterDet() { 
  slater = new SlaterDeterminant[numSlaterVariations];
  for (int i=0; i< numSlaterVariations; i++ ) 
    slater[i].init(&domain(), i);
  centralSlater = domain().getCentralSlater();
  slaterDeterminant = &(slater[centralSlater]);
}


// ************************* createCorrel *************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::createCorrel() {
  correl = new Correl[numCorrelVariations];
  for (int i=0; i<numCorrelVariations; i++) {
    correl[i].attach(domain());
    correl[i].attachFFunction(&(domain().getF()[i]));
    correl[i].createJastrowAndJastrowDiff();
  }
  centralCorrel = domain().getCentralCorrel();
  correlation = &(correl[centralCorrel]);
}


// ********************** setToNextParticle ***********************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::setToNextParticle() { 
  for (int i=0; i<numCorrelVariations; i++)
    correl[i].setToNextParticle();
  for (int i=0; i< numSlaterVariations; i++ )
    slater[i].setToNextParticle();
}


// ********************** setCurrentParticle **********************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::setCurrentParticle(int _currentParticle) { 
  for (int i=0; i<numCorrelVariations; i++)
    correl[i].setCurrentParticle(_currentParticle);
  for (int i=0; i< numSlaterVariations; i++ )
    slater[i].setCurrentParticle(_currentParticle);
}


// ******************* initializeThermalization *******************
// Called prior to starting the thermalization procedure.
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::initializeThermalization() { 
  correlation().initializeThermalization();
  setCurrentParticle(0);
}


// ************************ initializeVMC *************************
// Called inbetween VMC and thermalization
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::initializeVMC() { 
  for (int i=0; i<numCorrelVariations; i++) {
    correl[i].initializeThermalization();
    correl[i].initializeVMC();
  }
  for (int i=0; i< numSlaterVariations; i++)
    slater[i].initDiff();

  for (int i=0; i<numVariations; i++ )
    localWaveFunctions[i].init();
  setCurrentParticle(0);
}


// ************************ initNewVmcRun *************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::initNewVmcRun() { 
  for ( int i=0; i<numSlaterVariations; i++ ) {
    slater[i].initNewVmcRun();
  }
}


// ********************** createLocalSurface **********************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::createLocalSurface() {
  numVariations       = numSlaterVariations*numCorrelVariations;
  double* _centralSlaterDet   = &slaterDeterminant().getDet();
  double* _centralCorrelation = correlation().getCorrelationPtr();
  localWaveFunctions = new LocalWaveFunction[numVariations];
  for ( int i=0; i<numVariations; i++ ) {
    localWaveFunctions[i].initialize( &domain() );
    localWaveFunctions[i].attachCentralSlaterDet(_centralSlaterDet);
    localWaveFunctions[i].attachCentralCorrelation(_centralCorrelation);
  }

  int k=0;
  for ( int i=0; i<numSlaterVariations; i++ ) {
    for ( int j=0; j<numCorrelVariations; j++ ) {
      localWaveFunctions[k]
	.attachSlater(&slater[i].getDet(),
		      slater[i].getDiffRatiosPtr(),
		      &slater[i].getDDiffRatio(),
		      domain().getAlphaParam(i));
      localWaveFunctions[k]
	.attachCorrelation(correl[j].getCorrelationPtr(),
			   correl[j].getGradRatio(),
			   correl[j].getLaplaceRatio(),
			   domain().getBetaParam(j));
      k++;
    }
  }
}


// ************************* suggestMove **************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::suggestMove() {
  correlation().suggestMove();
  if (allowSpinFlip) slaterDeterminant().suggestMoveFlip();
  else slaterDeterminant().suggestMove();
}


// ********************* acceptThermalization *********************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::acceptThermalization() {
  correlation().acceptThermalizedMove();
  if (allowSpinFlip) {
    for (int i=0; i<numSlaterVariations; i++ )
      if (i!=centralSlater)
	slater[i].suggestMoveFlip();
    for (int i=0; i<numSlaterVariations; i++ )
      slater[i].acceptMoveFlip();
  }
  else {
    for (int i=0; i< numSlaterVariations; i++ )
      if (i!=centralSlater)
	slater[i].suggestMove();
    for (int i=0; i< numSlaterVariations; i++ )
      slater[i].acceptMove();
  }
}


// ********************* rejectThermalization *********************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::rejectThermalization() {
  correlation().rejectThermalizedMove();
  if (allowSpinFlip) {
    for (int i=0; i<numSlaterVariations; i++ )
      if (i!=centralSlater)
	slater[i].suggestMoveFlip();
    for (int i=0; i< numSlaterVariations; i++ )
      slater[i].rejectMoveFlip();
  }
  else {
    for (int i=0; i< numSlaterVariations; i++ )
      if (i!=centralSlater)
	slater[i].suggestMove();
    for (int i=0; i< numSlaterVariations; i++ )
      slater[i].rejectMove();
  }
}


// ************************** acceptMove **************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::acceptMove() {
  for (int i=0; i<numCorrelVariations; i++)
    if (i!=centralCorrel)
      correl[i].suggestMove();
  for (int i=0; i<numCorrelVariations; i++) {
    correl[i].acceptMove();
  }
  if (allowSpinFlip) {
    for (int i=0; i<numSlaterVariations; i++ )
      if (i!=centralSlater)
	slater[i].suggestMoveFlip();
    for (int i=0; i<numSlaterVariations; i++ )
      slater[i].acceptMoveFlip();
  }
  else {
    for (int i=0; i< numSlaterVariations; i++ )
      if (i!=centralSlater)
	slater[i].suggestMove();
    for (int i=0; i< numSlaterVariations; i++ )
      slater[i].acceptMove();
  }
}


// ************************** rejectMove **************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::rejectMove() {

  for (int i=0; i<numCorrelVariations; i++) {
    correl[i].rejectMove();
  }
  if (allowSpinFlip) {
    for (int i=0; i<numSlaterVariations; i++ )
      if (i!=centralSlater)
	slater[i].suggestMoveFlip();
    for (int i=0; i< numSlaterVariations; i++ )
      slater[i].rejectMoveFlip();
  }
  else {
    for (int i=0; i< numSlaterVariations; i++ )
      if (i!=centralSlater)
	slater[i].suggestMove();
    for (int i=0; i< numSlaterVariations; i++ )
      slater[i].rejectMove();
  }
}


// **************************** sample ****************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::sample() {
  for (int i=0; i<numCorrelVariations; i++) {
    correl[i].calculateCorrelation();
    correl[i].calculateGradAndLaplacianRatios();
  }

  for (int i=0; i< numSlaterVariations; i++ ) {
    slater[i].calcDDiffRatio();
    slater[i].calcDiffRatios();
  }
  double potentialEnergy = domain().getNucleusElectronPotential() 
    + domain().getInterElectronicPot();
  for (int i=0; i<numVariations; i++) {
    localWaveFunctions[i].sample(potentialEnergy);
  }
}


// *************************** summary ****************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::summary() {
  for (int i=0; i<numVariations; i++)
    localWaveFunctions[i].summary();
}


// ************************ summaryLowest *************************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::summaryLowest() {
  if (varianceOptimization)  *outputFile << "Lowest Variance for: ";
  else  *outputFile << "Lowest Energy for: ";
  localWaveFunctions[findLowestWaveFunction()].summary();
}


// ******************** findLowestWaveFunction ********************
// Returns the integer value of the lovalWaveFunction with the lowest 
// energy or variance
template <class SlaterDeterminant>
int Variations<SlaterDeterminant>::findLowestWaveFunction() {
  if (varianceOptimization) {
    int lowest=-1;
    double minVariance = 999;
    for (int i=0; i<numVariations; i++) {
      double variance = localWaveFunctions[i].getVariance();
      if ( variance < minVariance) {
	minVariance = variance;
	lowest = i;
      }
    }
    if (lowest ==-1) {
      *outputFile << "Error finding variance minimum in class Variation" 
		  << endl << "Minimum variance >= 999!" << endl;
      return -1;
    }
    else return lowest;
  }
  else {
    int lowest=-1;
    double minEnergy = 0;
    for (int i=0; i<numVariations; i++) {
      double energy = localWaveFunctions[i].getAverageEnergy();
      if ( energy < minEnergy) {
	minEnergy = energy;
	lowest = i;
      }
    }
    if (lowest ==-1) {
      *outputFile << "Error finding energy minimum in class Variation" 
		  << endl << "Minimum energy >= 0!" << endl;
      return -1;
    }
    else return lowest;
  }
}


// *********************** getLowestEnergy ************************
template <class SlaterDeterminant>
double Variations<SlaterDeterminant>::getLowestEnergy() {
  return localWaveFunctions[findLowestWaveFunction()].getAverageEnergy();
}


// ********************** getLowestVariance ***********************
template <class SlaterDeterminant>
double Variations<SlaterDeterminant>::getLowestVariance() {
  return localWaveFunctions[findLowestWaveFunction()].getVariance();
}


// ********************* getLowestAlphaParams *********************
template <class SlaterDeterminant>
double* Variations<SlaterDeterminant>::getLowestAlphaParams() {
  return localWaveFunctions[findLowestWaveFunction()].getAlphaParams();
}


// ********************* getLowestBetaParams **********************
template <class SlaterDeterminant>
double* Variations<SlaterDeterminant>::getLowestBetaParams() {
  return localWaveFunctions[findLowestWaveFunction()].getBetaParams();
}


// ********************** setReferenceEnergy **********************
template <class SlaterDeterminant>
void Variations<SlaterDeterminant>::setReferenceEnergy(double E) {
  for (int i=0; i<numVariations; i++)
    localWaveFunctions[i].setReferenceEnergy(E);
}

#endif
\end{lstlisting}


\newpage


% *************************************************************
% *                                                           *
% *                           Vmc.h                           *
% *                                                           *
% *************************************************************
\subsection{Vmc.h}
\begin{lstlisting}
#ifndef Vmc_IS_INCLUDED
#define Vmc_IS_INCLUDED

#include "../Domain/Domain.h"
#include "../Correlation/Correlation.h"
#include "../SlaterDet/SlaterDet.h"
#include "../Ref/Ref.h"
#include "../Variations/Variations.h"
#include "../Walker/Walker.h"

// ****************************************************************
// *                             VMC                              *
// ****************************************************************
template <class SlaterDeterminant>
class Vmc {
 protected:

  Ref<Domain>                          domain;
  Ref<SlaterDeterminant>               slaterDeterminant;
  Ref<Correl>                          correlation;
  Ref<Walker<SlaterDeterminant> >      walker;
  Ref<Variations<SlaterDeterminant> >  wf;
  Ref<Random2>                         randomMetro;

  int      numThermalization;  // Number of thermalization steps
  int      numCycles;          // Number of Monte Carlo cycles

  ofstream *outputFile;        // Outputfile
  string   thermalizationType; // Determines way to perform 
                               // the thermalization(s).
  string   vmcType;            // Determines way to perform 
                               // the VMC run(s).
  int      uniDirectionalMovement; // Boolean determining whether
                               // we to search for a minima until
                               // movement in parameter space is 
                               // no longer uni-directional(1) or
                               // not(0).
  int      numberVmcRuns;      // Either the number of VMC runs 
                               // performed or the maximum number 
                               // of VMC runs we allow when 
                               // performing a (uni-directional) 
                               // search for minima.

  int      numberOfUniDirectionalMoves; // Number of uni-directional
                               // moves.
  int      rank;               // The rank or prosess number of the
                               // MPI run.
  double   centerRank;         // (Number of ranks + 1)/2.

 public:
  Vmc(Domain& _domain);
  void thermalization();
  void adaptiveStepThermalization(); 
  void vmcSome(); 
  void vmcOneParticleAtATime(); 
  void initNextRun();
  void run();
  
};

#include "Vmc.cpp"

#endif
\end{lstlisting}



% *************************************************************
% *                                                           *
% *                          Vmc.cpp                          *
% *                                                           *
% *************************************************************
\subsection{Vmc.cpp}
\begin{lstlisting}
#ifndef VmcCPP_IS_INCLUDED
#define VmcCPP_IS_INCLUDED

#include "Vmc.h"



// ****************************************************************
// *                             VMC                              *
// ****************************************************************
//
// ***************************** Vmc ******************************
template <class SlaterDeterminant>
Vmc<SlaterDeterminant>::Vmc(Domain& _domain) : domain(_domain) { 

  wf                = new Variations<SlaterDeterminant>( domain() );
  slaterDeterminant = &(wf().getSlaterDet());
  correlation       = &(wf().getCorrelation());
  randomMetro       = domain().getRandomMetro();
  walker            = new Walker<SlaterDeterminant>( domain(),  
						     slaterDeterminant(), 
						     randomMetro(), 
						     correlation(), 
						     wf() );

  outputFile           = domain().getOutputFile();
  numThermalization    = domain().getNumThermalization();
  numCycles            = domain().getNumCycles();
  rank                 = domain().getRank();
  centerRank           = (domain().getSize() - 1.0) / 2.0;

  thermalizationType            = domain().getThermalizationType();
  vmcType                       = domain().getVmcType();
  uniDirectionalMovement        = domain().getUniDirectionalMovement();
  numberVmcRuns                 = domain().getNumberVmcRuns();
  numberOfUniDirectionalMoves   = domain().getNumberOfUniDirectionalMoves();
  *outputFile << endl;
}


// *********************** thermalization *************************
template <class SlaterDeterminant>
void Vmc<SlaterDeterminant>::thermalization() { 
  *outputFile << " Thermalization: " << numThermalization;
  wf().initializeThermalization();
  for (int j = 0; j < numThermalization; j++) {
    walker().doThermalizationStep();
  }
}


// ***************** adaptiveStepThermalization *******************
template <class SlaterDeterminant>
void Vmc<SlaterDeterminant>::adaptiveStepThermalization() { 
  *outputFile << " Thermalization: " << numThermalization;
  wf().initializeThermalization();
  int frac = domain().getNumberSeekAcceptance();
  double soughtAcceptance = domain().getSoughtAcceptance();
  if (domain().getVarySeekWithRank()) 
    soughtAcceptance -= 
      (centerRank - rank) * domain().getVarySeekWithRankStep();
  int numThermFrac = numThermalization/frac;
  if (numThermFrac>0) {
    for (int i=0; i<frac; i++) {
      int acceptance = 0;
      for (int j = 0; j < numThermFrac; j++) {
	acceptance += walker().doThermalizationStep();
      }
      domain().changeStepLen(numThermFrac, acceptance, soughtAcceptance);
    }
  }
  *outputFile << " StepLenght changed to: " <<  domain().getStepLen();
}


// ************************** vmcSome *****************************
template <class SlaterDeterminant>
void Vmc<SlaterDeterminant>::vmcSome() { 
  int numParticles = domain().getNumParticles();
  domain().initVMC();
  wf().initializeThermalization();
  wf().initializeVMC();
  walker().resetAcceptance();
  *outputFile << " VMC run: " << numCycles;
  int acceptance = 0;
  for (int i = 0; i < numCycles; i++) {
    for (int j = 0; j < numParticles; j++) {
      acceptance += walker().doRandomStep();
    }
    wf().sample();
  }
  *outputFile << " Acceptance: " 
	      << (((double)acceptance) / (numCycles) / numParticles)
	      << endl << endl;
  wf().summary();
  *outputFile << endl;
  wf().summaryLowest();
}


// ******************* vmcOneParticleAtATime **********************
template <class SlaterDeterminant>
void Vmc<SlaterDeterminant>::vmcOneParticleAtATime() { 
  domain().initVMC();
  wf().initializeThermalization();
  wf().initializeVMC();
  walker().resetAcceptance();
  *outputFile << " VMC run: " << numCycles;
  int acceptance = 0;
  for (int i = 0; i < numCycles; i++) {
    acceptance += walker().doRandomStep();
    wf().sample();
  }

  *outputFile << " Acceptance: " << 
    (((double)acceptance) / (numCycles))   << endl << endl;
  wf().summary();
  *outputFile << endl;
  wf().summaryLowest();
}


// ************************ initNextRun ***************************
template <class SlaterDeterminant>
void Vmc<SlaterDeterminant>::initNextRun() { 
  domain().setReferenceEnergy(wf().getLowestEnergy());

  domain().setCentralAlphaParam(wf().getLowestAlphaParams());
  domain().calculateAlphaParamArray();

  domain().setCentralBetaParam(wf().getLowestBetaParams());
  domain().calculateBetaParamArray();

  domain().init();
  wf().initNewVmcRun();
}


// ***************************** run ******************************
template <class SlaterDeterminant>
void Vmc<SlaterDeterminant>::run() { 

  domain().initSummary();

  for (int i=0; i<numberOfUniDirectionalMoves; i++) {

    int numRuns=0;
    int uniDirection=1;
    *outputFile << "::::::::::::::::::::::::::::::::" 
		<< "::::::::::::::::::::::::::::::::" << endl;

    while ( (uniDirection) & (numRuns<numberVmcRuns) ) {
      domain().Summary();
      *outputFile << endl;

      // Thermalization
      if (thermalizationType == "thermalization" ) thermalization();
      else if (thermalizationType == "adaptiveStepThermalization" ) 
	adaptiveStepThermalization();
      else *outputFile 
	<< "Error in Vmc::run. Could not perform thermalization." 
	<< endl << "  Input thermalizationType not known." << endl;

      // VMC
      if (vmcType == "vmcSome" ) vmcSome();
      else if (vmcType == "vmcOneParticleAtATime" ) vmcOneParticleAtATime();
      else *outputFile << "Error in Vmc::run. Could not perform vmc." 
		       << endl << "  Input vmcType not known." << endl;

      *outputFile << "One VMC run finished." << endl;

      if (uniDirectionalMovement)
	uniDirection = domain().isMovementUniDirectional
	  (wf().getLowestAlphaParams(), wf().getLowestBetaParams() );
      if (uniDirection) initNextRun();
      numRuns++;
    }  

    if ( (uniDirectionalMovement) & (numRuns==numberVmcRuns) ) 
      *outputFile << "Error in Vmc:run! Could not find minima in numRuns = " 
		  << numberVmcRuns << " runs." << endl;

    if (uniDirectionalMovement) domain().initUniDirectionalIndicator();

    *outputFile << endl << endl;

    domain().increaseNumCycles();
    numCycles = domain().getNumCycles();
    domain().increaseNumThermalization();
    numThermalization = domain().getNumThermalization();
    domain().reduceLocalArea();
    initNextRun();

  }

}

#endif
\end{lstlisting}


\newpage


% *************************************************************
% *                                                           *
% *                           Walker.h                        *
% *                                                           *
% *************************************************************
\subsection{Walker.h}
\begin{lstlisting}
#include "../Variations/Variations.h"

// ****************************************************************
// *                           WALKER                             *
// ****************************************************************
template <class SlaterDeterminant>
class Walker {
 protected:

  int             accepted;         // The number of accepted steps.
  double          ratio;            // The product of slaterRatio 
                                    // and correlationRatio.
  RefFund<double> slaterRatio;      // The slaterRatio.
  RefFund<double> correlationRatio; // The correlationRatio.

  Ref<Random2>                        random;
  Ref<Domain>                         domain;
  Ref<SlaterDeterminant>              slaterDeterminant;
  Ref<Correl>                         correlation;
  Ref<Variations<SlaterDeterminant> > variations;

 public:
  Walker(Domain& _domain,  
	 SlaterDeterminant& _slaterDeterminant, 
	 Random2& _random, Correl& _correlation, 
	 Variations<SlaterDeterminant>& _variations);

  int                doThermalizationStep();
  int                doRandomStep();
  void               resetAcceptance();
  int                getAcceptance();
  SlaterDeterminant* getSlaterDeterminantPtr() {return &(slaterDeterminant());}
};

#include "Walker.cpp"

#endif
\end{lstlisting}



% *************************************************************
% *                                                           *
% *                          Walker.cpp                       *
% *                                                           *
% *************************************************************
\subsection{Walker.cpp}
\begin{lstlisting}
#ifndef WalkerCPP_IS_INCLUDED
#define WalkerCPP_IS_INCLUDED

#include "Walker.h"


// *************************** Walker ****************************
template <class SlaterDeterminant>
Walker<SlaterDeterminant>::Walker(Domain& _domain, 
				  SlaterDeterminant& _slaterDeterminant, 
				  Random2& _random, Correl& _correlation, 
				  Variations<SlaterDeterminant>& _variations) {
  random            = _random;
  domain            = _domain;
  slaterDeterminant = _slaterDeterminant;
  correlation       = _correlation;
  slaterRatio       = &slaterDeterminant().getRatio();
  correlationRatio  = correlation().getRatioPtr();
  variations        = _variations;
}


// ******************** doThermalizationStep *********************
template <class SlaterDeterminant>
int Walker<SlaterDeterminant>::doThermalizationStep() {
  domain().suggestMove();
  //domain().proposeFlip();
  variations().suggestMove();
  ratio = slaterRatio()*correlationRatio();

  // THE METROPOLIS TEST!
  if ( (ratio*ratio) > random().getNum()) {
    domain().acceptThermalizedMove();
    variations().acceptThermalization();
    accepted = 1;
  }
  else {
    domain().rejectThermalizedMove();
    variations().rejectThermalization();
    accepted = 0;
  }
  variations().setToNextParticle();
  domain().setToNextParticle();
  return accepted;
}

// ************************ doRandomStep *************************
template <class SlaterDeterminant>
int Walker<SlaterDeterminant>::doRandomStep() {
  domain().suggestMove();
  //domain().proposeFlip();
  variations().suggestMove();
  ratio = slaterRatio()*correlationRatio();
  // THE METROPOLIS TEST!
  if ( (ratio*ratio) > random().getNum()) {
    domain().acceptMove();
    variations().acceptMove();
    accepted = 1;
  }
  else {
    //domain().rejectTrialPosition();
    domain().rejectMove();
    variations().rejectMove();
    accepted = 0;
  }  
  variations().setToNextParticle();
  domain().setToNextParticle();
  return accepted;
}


// ********************** resetAcceptance ************************
template <class SlaterDeterminant>
void Walker<SlaterDeterminant>::resetAcceptance() {
  slaterDeterminant().resetAcceptances();
}


// *********************** getAcceptance *************************
template <class SlaterDeterminant>
int Walker<SlaterDeterminant>::getAcceptance() {
  return slaterDeterminant().getMoveAcceptance();
}

#endif
\end{lstlisting}


\newpage




% *************************************************************
% *                                                           *
% *                        SpinFactors.h                      *
% *                                                           *
% *************************************************************
\subsection{SpinFactors.h}
\begin{lstlisting}
#ifndef SpinFactors_IS_INCLUDED
#define SpinFactors_IS_INCLUDED

#include <iostream>
using namespace std;

#ifndef dotProduct_IS_INCLUDED
#define dotProduct_IS_INCLUDED

inline double dotProduct(double* array1, double* array2, int dim) {
  double* a1 = array1 - 1;
  double* a2 = array2 - 1;
  double product = 0;
  for (int i=0; i<dim; i++)
    product += (*++a1)*(*++a2);
  return product;
}
#endif

class SpinFactors {

protected:
  int     numParticles;    // Number of particles.
  int     Nmatrix;         // Number of elements in the upper-
                           // triangular matrices.
  int     currentParticle; // This is the particle that 
                           // currently is (proposed) moved.
  int     otherParticle;   // Particle to exchange spin with.

  int*    spinArray;       // Array directly accesing the 
                           // particle spins.
  int*    _spinArray;      // spinArray pointer.
  int*    currentSpin;     // Spin of current particle.
  int*    otherSpin;       // Spin of other particle.

  double* newFactor;       // Array containing new factors.
  double* oldFactor;       // Array containing old factors.
  double* otherDifference; // Distance between new and old factors.
  double* matrix;          // Upper triangular matrix containing 
                           // the spin factors (1/2 for like spins,
                           // 1 for anti-parllel spin).
  double* _newFactor;      // newFactor pointer.
  double* _oldFactor;      // oldFactor pointer.
  double* _otherDifference;// otherDifference pointer.
  double* _matrix;         // matrix pointer. 

  int     quarterCusp;     // Boolean (1 = quarter cusp for like
                           // spin electrons, 0 = cusp 1/2 for all 
                           // electrons).
  int     spinFlip;        // Boolen determining wether we allow spin 
                           // flip.

  void    dumpNewFactor();
  void    dumpOldFactor();
  void    dumpOtherDifference();
  void    setNewFactor(double value);
public:
  SpinFactors() {}
  void    allocate(int _numParticles, int* _spinArray);
  void    init();
  // Call this routine if no spins are flipped 
  // (OR the two spins are equal) 
  void    calculateNoFlipFactors();
  // Call this routine ONLY if the two spins differ
  void    calculateFlipFactors();
  void    setToNextParticle();
  void    setCurrentParticle(int _currentParticle) 
    {currentParticle = _currentParticle;}
  void    setOtherParticle(int _otherParticle) 
    {otherParticle= _otherParticle;}
  void    setSpinFlip(int _spinFlip)       {spinFlip = _spinFlip;}
  void    setQuarterCusp(int _quarterCusp) {quarterCusp = _quarterCusp;}
  double* getNewFactor()       {return newFactor;}
  double* getOldFactor()       {return oldFactor;}
  double* getOtherDifference() {return otherDifference;}
  double* getMatrix()          {return matrix;}
  int*    getSpinFlip()        {return &spinFlip;}
  int*    getOtherParticle()   {return &otherParticle;}
  void    calculateMatrix();
  void    summaryNoFlip();
  void    summaryFlip();
  void    summayMatrix();
};

#endif
\end{lstlisting}



% *************************************************************
% *                                                           *
% *                       SpinFactors.cpp                     *
% *                                                           *
% *************************************************************
\subsection{SpinFactors.cpp}
\begin{lstlisting}
#include "SpinFactors.h"

// ************************* allocate ****************************
void SpinFactors::allocate(int _numParticles, int* _spinArray) {
  numParticles    = _numParticles;
  Nmatrix         = (numParticles*(numParticles-1))/2;
  spinArray       = _spinArray;
  newFactor       = new double[numParticles - 1];
  oldFactor       = new double[numParticles - 1];
  otherDifference = new double[numParticles - 1];
  matrix          = new double[Nmatrix];
  init();
}

// *************************** init ******************************
void SpinFactors::init() {
  setCurrentParticle(0);
  setOtherParticle(0);
  setSpinFlip(0);
  setNewFactor(1);
}


// ****************** calculateNoFlipFactors *********************
// Call this routine if no spins are flipped 
// (OR the two spins are equal) 
void SpinFactors::calculateNoFlipFactors() {
  _spinArray  = spinArray;
  currentSpin = _spinArray + currentParticle;
  _newFactor  = newFactor  - 1;
  for (int i=0; i<currentParticle; i++)
    if ( (*_spinArray++)==(*currentSpin) ) (*++_newFactor)=0.5;
    else (*++_newFactor)=1;
  for (int i=currentParticle+1; i<numParticles; i++)
    if ( (*++_spinArray)==(*currentSpin) ) (*++_newFactor)=0.5;
    else (*++_newFactor)=1;
}

// ******************* calculateFlipFactors **********************
// Call this routine ONLY if the two spins differ
void SpinFactors::calculateFlipFactors() {
  _spinArray  = spinArray;
  currentSpin = spinArray + currentParticle;
  _newFactor  = newFactor - 1;
  _oldFactor  = oldFactor - 1;
  for (int i=0; i<currentParticle; i++)
    if ( (*_spinArray++)==(*currentSpin) ) {
      (*++_newFactor)=1;
      (*++_oldFactor)=0.5;
    }
    else {
      (*++_newFactor)=0.5;
      (*++_oldFactor)=1;
    }
  for (int i=currentParticle+1; i<numParticles; i++)
    if ( (*++_spinArray)==(*currentSpin) ) {
      (*++_newFactor)=1;
      (*++_oldFactor)=0.5;
    }
    else {
      (*++_newFactor)=0.5;
      (*++_oldFactor)=1;
    }
  *(newFactor+otherParticle-(otherParticle>currentParticle)) = 1;

  _spinArray       = spinArray;
  otherSpin        = spinArray + otherParticle;
  _otherDifference = otherDifference - 1;
  for (int i=0; i<otherParticle; i++)
    if ( (*_spinArray++)==(*otherSpin) ) (*++_otherDifference)=0.5;
    else (*++_otherDifference)=-0.5;
  for (int i=otherParticle+1; i<numParticles; i++)
    if ( (*_spinArray++)==(*otherSpin) ) (*++_otherDifference)=0.5;
    else (*++_otherDifference)=-0.5;
  *(otherDifference+currentParticle-(currentParticle>otherParticle)) = 0;
}


// ********************* setToNextParticle ************************
void SpinFactors::setToNextParticle() {
  currentParticle++;
  if (currentParticle == numParticles) setCurrentParticle(0);
}


// ********************** calculateMatrix ************************
void SpinFactors::calculateMatrix() {
  _matrix = matrix-1;
  for (int i=0; i<numParticles-1; i++)
    for (int j=i+1; j<numParticles; j++)
      if ( ( spinArray[i]==spinArray[j] ) & (quarterCusp) ) 
	(*++_matrix) = 0.5;
      else (*++_matrix) = 1;
}


// *********************** setNewFactor *************************
void SpinFactors::setNewFactor(double value) {
  _newFactor = newFactor - 1;
  for (int i=0; i<numParticles-1; i++)
    (*++_newFactor) = value;
}


// *********************** dumpNewFactor *************************
void SpinFactors::dumpNewFactor() {
  cerr << "Current Particle=" << currentParticle << " newFactor=[ ";
  _newFactor = newFactor - 1;
  for (int i=0; i<numParticles-1;i++)
    cerr << (*++_newFactor) << " ";
  cerr << " ]" << endl;
}


// *********************** dumpOldFactor *************************
void SpinFactors::dumpOldFactor() {
  cerr << "Current Particle=" << currentParticle << " oldFactor=[ ";
  _oldFactor = oldFactor - 1;
  for (int i=0; i<numParticles-1;i++)
    cerr << (*++_oldFactor) << " ";
  cerr << " ]" << endl;
}


// ******************** dumpOtherDifference **********************
void SpinFactors::dumpOtherDifference() {
  cerr << "Current Particle=" << currentParticle << "Other Particle=" << otherParticle << " otherDifference=[ ";
  _otherDifference = otherDifference - 1;
  for (int i=0; i<numParticles-1;i++)
    cerr << (*++_otherDifference) << " ";
  cerr << " ]" << endl;
}


// *********************** summaryNoFlip *************************
void SpinFactors::summaryNoFlip() {
  dumpNewFactor();
}


// ************************ summaryFlip **************************
void SpinFactors::summaryFlip() {
  dumpNewFactor();
  dumpOldFactor();
  dumpOtherDifference();
}


// ************************ summayMatrix *************************
void SpinFactors::summayMatrix() {
  cerr << "Matrix =" << endl;
  _matrix = matrix-1;
  for (int i=0; i<numParticles-1; i++) {
    for (int j=0; j<i+1; j++)
      cerr << 0 << " ";
    for (int j=i+1; j<numParticles; j++)
      cerr << (*++_matrix) << " ";
  cerr << endl;
  }
}
\end{lstlisting}



