In this chapter the Variational Monte Carlo program will be
presented. We will look at the structure and the implementation of the
program, and on the class structure. Details about the code will be
given and finally a description of the classes making up the program
will be presented.
%\todo{More introduction to implementation}


\section{Structure} \label{sec:Structure}

	For short, straightforward programs the structure of the code is more or less irrelevant. But in scientific programming a program easily becomes large and complex, and it is therefore important to structure the code in an orderly manner. This makes it not only easier to debug, but also makes it easier for others to read and understand what all parts of the program does. 

	For large programs, like the VMC solver program in this thesis, it is generally recommended to use object orientation. This makes the program tidy and flexible. From the main function the solver program in this thesis initializes the VMC solver class, {\tt VMCSolver}. For an overview of the {\tt VMCSolver}-class, see Fig. \ref{fig:schematic}. This class will in turn initialize a class for the trialfunction, a class for the Slater determinant, and a class for the derivatives associated with the trial function. See Fig. \ref{fig:classes} for an overview of the subclasses.

	The job of the {\tt main}-function in the variational Monte Carlo solver is to gather input parameters like number of cycles in the Monte Carlo simulation, and what kind of test should be run. The tests include finding optimal $\alpha$- and $\beta$-values and testing for different oscillator frequencies, $\omega$, and calculating the ground state energy with the found variational parameters while saving detailed data like positions of each particle. Each of the tests will call the {\tt VMCSolver}-class as needed, and thus start the simulation process. When initialized by the {\tt main}-function, the {\tt VMCSolver}-class will initialize the other classes {\tt SlaterDeterminant}, {\tt Derivatives}, {\tt Orbitals}, and {\tt Trialfunction}. 

	The {\tt Trialfunction}-class acts as a wrapper for the {\tt QuantumDots}-class. This is not strictly necessary for our needs, as the only trialfunction we use is the quantum dots one. However, we wish to make the program flexible and to make it simple to add additional parts. Therefore, to be able to choose between different trialfunctions easily, we need a class like the {\tt Trialfunction}-class. 

	Consisting of a number of Hermite polynomials, the orbital functions are generated by a Python script. By using SymPy \cite{sympy} we can easily find the analytical expressions of the derivatives and gradients of the orbital functions. The {\tt Orbitals}-class and its subclasses are therefore maintained by the Python script. The {\tt Orbitals}-class itself acts as an interface, where values for the orbitals and their derivative functions can be extracted. 

	

	\begin{figure}
		\center
		\begin{tikzpicture}[%
		    >=triangle 60,              % Nice arrows; your taste may be different
		    start chain=going below,    % General flow is top-to-bottom
		    node distance=6mm and 47mm, % Global setup of box spacing
		    every join/.style={norm},   % Default linetype for connecting boxes
		    ]
		% ------------------------------------------------- 
		% A few box styles 
		% <on chain> *and* <on grid> reduce the need for manual relative
		% positioning of nodes
		\tikzset{
		  base/.style={draw, on chain, on grid, text centered, minimum height=4ex},
		  proc/.style={base, rectangle, text width=10em},
		  test/.style={base, diamond, aspect=2, text width=5em},
		  term/.style={proc, rounded corners},
		  % coord node style is used for placing corners of connecting lines
		  coord/.style={coordinate, on chain, on grid, node distance=6mm and 45mm},
		  % nmark node style is used for coordinate debugging marks
		  nmark/.style={draw, cyan, circle, font={\sffamily\bfseries}},
		  % -------------------------------------------------
		  % Connector line styles for different parts of the diagram
		  norm/.style={->, draw, lcnorm},
		  free/.style={->, draw, lcfree},
		  cong/.style={->, draw, lccong},
		  it/.style={font={\small\itshape}}
		}
		% -------------------------------------------------
		% Start by placing the nodes
		\node[proc, densely dotted, it] (init) {Initialize solver};
		\node[term, join] (split)      {Split into several processes for MPI};
		\node[term, join] (position)      {Suggest move};
		\node[term, join] (SD) { Compute/update \( |D| \) };
		\node[term, join ] (metro) {Compute Metropolis Ratio};
		\node[test, densely dotted , join ]	(test)	{\(R \ge r\)};
		\node[term]	(new_pos)	{\(\vb{r}^{old} = \vb{r}^{new}\)};
		\node[term, join ]	(energy)	{ Store \(E_L\) };
		\node[test, densely dotted ,join ]	(last)	{Last cycle?};
		\node[term]	(end)	{Collect samples};


		%Setting up the nodes on the side
		\node [term, right=of SD] (trialfunction) {Compute \( \psi_T(\vb{r}) \)};
		\node [term, left=of SD] (quantum) { Compute  Quantumforce};
		\node[term, left=of test] (old_pos) {Keep \(  \vb{r}^{old} \)};
		\node [coord, left=of new_pos] (c1)  {};    
		\node[coord, right=of last]	(around1){};
		\node[coord, right=of around1] (around2) {};
		\node[coord, right=of position]	(around3){};
		\node[coord, right=of around3]	(around4){};


		%Draw new links between boxes
		% \path (SD.south) to node [near start, xshift=1em] {$y$} (quantum);
		\draw [->,lcnorm] (SD.west) -- (quantum);
		\draw [->,lcnorm] (SD.east) -- (trialfunction);
		\draw [->, lcnorm] (quantum.south) -- (metro);
		\draw [->, lcnorm] (trialfunction.south) -- (metro);
		\draw [*->, lccong, , dotted] (test.west) -- (old_pos);
			\path (test.west) to node [ yshift = -1em] {no} (old_pos);
		\draw [*->, lcfree, dotted] (test.south) -- (new_pos);
			\path (test.south) to node [xshift = -1em]{yes} (new_pos);

		\draw [-, lcnorm] (old_pos.south) -- (c1);
		\draw [->, lcnorm] (c1.south) -- (energy);

		\draw[*-, lccong, dotted] (last.east) -- (around2);
			\path (last.east) to node [yshift = -1em] {no} (last);
			\draw[-, lccong, dotted] (around2.east) -- (around4);
			\draw[->, lccong, dotted] (around4) -- (position);

		\draw [*->, lcfree, dotted] (last.south) -- (end);
			\path (last.south) to node [xshift = +1em]{yes} (end);


		\end{tikzpicture}
		\caption{Schematic overview over the workflow of the VMC solver. The solver is initialized and called by the {\tt main}-function.}
		\label{fig:schematic}
	\end{figure}

%\todo{Fix flowcharts.}

\subsection{Class structure}

	Classes in a large program can be many hundred or even thousands of lines long. This makes it messy and cumbersome to keep all classes in a single file. A standard way to deal with this is to have a file for each class and subclass. This is not only much more tidy than having everything in a single file, but has the practical benefit of not needing to recompile the entire program on every compilation; it suffices to compile only the changed classes. This can cut down compilation times considerably.

	\begin{figure}
		\center
		\begin{tikzpicture}[%
			    >=triangle 60,              % Nice arrows; your taste may be different
			    start chain=going below,    % General flow is top-to-bottom
			    node distance=6mm and 35mm, % Global setup of box spacing
			    every join/.style={norm},   % Default linetype for connecting boxes
			    ]
			% ------------------------------------------------- 
			% A few box styles 
			% <on chain> *and* <on grid> reduce the need for manual relative
			% positioning of nodes
			\tikzset{
			  base/.style={draw, on chain, on grid, text centered, minimum height=4ex},
			  proc/.style={base, rectangle, text width=10em},
			  test/.style={base, diamond, aspect=2, text width=5em},
			  term/.style={proc, rounded corners},
			  % coord node style is used for placing corners of connecting lines
			  coord/.style={coordinate, on chain, on grid, node distance=6mm and 45mm},
			  % nmark node style is used for coordinate debugging marks
			  nmark/.style={draw, cyan, circle, font={\sffamily\bfseries}},
			  % -------------------------------------------------
			  % Connector line styles for different parts of the diagram
			  norm/.style={->, draw, lcnorm},
			  free/.style={->, draw, lcfree},
			  cong/.style={->, draw, lccong},
			  it/.style={font={\small\itshape}}
			}

			%Center column
			\node[term, fill=lcfree!25,  text centered] (solver) {VMCSolver};
			\node[coord]	(blank)	{};
			\node[coord]	(empty)	{};
			\node[coord]	(blank2)	{};
			

			% Bottom columns
			\node[term,  right= 0.5 cm and 0.5 cm of blank2] (trialfunction)	{Trialfunction};
				\draw[->, lcnorm]	(solver.south) -- (trialfunction);
			\node[term, join]	(diff)	{QuantumDots}; %{He, Be, Ne, H\(_2\) or Be\(_2\)}

			\node[term,  left= 0.5 cm and 0.5 cm of blank2] (orbitals)	{Orbitals};
				\draw[->, lcnorm]	(solver.south) -- (orbitals);
			\node[term, join]	(HO)	{HarmonicOscillator};

			%Sides with lines drawn
			\node[term, right= 2cm and 3cm of blank] (derivatives) {Derivatives};
				\draw[->, lcnorm] (solver.east) -- (derivatives.west);

			\node[term, left= 2cm and 3cm of blank] 	(slater)	{SlaterDeterminant};
				\draw[->, lcnorm] (solver.west) -- (slater.east);

			%Dotted lines between the connected classes
			%\draw[-, lcfree, densely dotted] (slater.east) -- (derivatives.west);
			%\draw[-, lcfree, densely dotted] (slater.east) -- (trialfunction.north);
			%\draw[-, lcfree, densely dotted] (slater.east) -- (orbitals.north);
			%\draw[-, lcfree, densely dotted] (trialfunction.north) -- (derivatives.west);


		\end{tikzpicture}

		\caption{Class and subclass structure used by the program. The {\tt VMCSolver}-class initializes the other classes {\tt SlaterDeterminant}, {\tt Derivatives}, {\tt Orbitals}, and {\tt Trialfunction}. Classes {\tt Orbitals} and {\tt Trialfunction} each has their own subclasses.}
		\label{fig:classes}
	\end{figure}
